{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/GitRepos/WineJS/app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"C:/GitRepos/WineJS/app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"C:/GitRepos/WineJS/app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"C:/GitRepos/WineJS/app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"C:/GitRepos/WineJS/app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:/GitRepos/WineJS/app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = function isHTMLElement(value) {\n  return value instanceof HTMLElement;\n};\n\nvar EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nvar VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all'\n};\nvar VALUE = 'value';\nvar SELECT = 'select';\nvar UNDEFINED = 'undefined';\nvar INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nfunction attachEventListeners(_ref, shouldAttachChangeEvent, handleChange) {\n  var ref = _ref.ref;\n\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n\nvar isNullOrUndefined = function isNullOrUndefined(value) {\n  return value == null;\n};\n\nvar isObjectType = function isObjectType(value) {\n  return typeof value === 'object';\n};\n\nvar isObject = function isObject(value) {\n  return !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !(value instanceof Date);\n};\n\nvar isKey = function isKey(value) {\n  return !Array.isArray(value) && (/^\\w*$/.test(value) || !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n};\n\nvar compact = function compact(value) {\n  return value.filter(Boolean);\n};\n\nvar stringToPath = function stringToPath(input) {\n  return compact(input.replace(/[\"|']/g, '').replace(/\\[/g, '.').replace(/\\]/g, '').split('.'));\n};\n\nfunction set(object, path, value) {\n  var index = -1;\n  var tempPath = isKey(path) ? [path] : stringToPath(path);\n  var length = tempPath.length;\n  var lastIndex = length - 1;\n\n  while (++index < length) {\n    var key = tempPath[index];\n    var newValue = value;\n\n    if (index !== lastIndex) {\n      var objValue = object[key];\n      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar transformToNestObject = function transformToNestObject(data) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  for (var key in data) {\n    !isKey(key) ? set(value, key, data[key]) : value[key] = data[key];\n  }\n\n  return value;\n};\n\nvar isUndefined = function isUndefined(val) {\n  return val === undefined;\n};\n\nvar get = function get(obj, path, defaultValue) {\n  var result = compact(path.split(/[,[\\].]+?/)).reduce(function (result, key) {\n    return isNullOrUndefined(result) ? result : result[key];\n  }, obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\n\nvar focusOnErrorField = function focusOnErrorField(fields, fieldErrors) {\n  for (var key in fields) {\n    if (get(fieldErrors, key)) {\n      var field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          if (isUndefined(field.ref.focus())) {\n            break;\n          }\n        } else if (field.options) {\n          field.options[0].ref.focus();\n          break;\n        }\n      }\n    }\n  }\n};\n\nvar removeAllEventListeners = function removeAllEventListeners(ref, validateWithStateUpdate) {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n\nvar defaultReturn = {\n  isValid: false,\n  value: ''\n};\n\nvar getRadioValue = function getRadioValue(options) {\n  return Array.isArray(options) ? options.reduce(function (previous, option) {\n    return option && option.ref.checked ? {\n      isValid: true,\n      value: option.ref.value\n    } : previous;\n  }, defaultReturn) : defaultReturn;\n};\n\nvar getMultipleSelectValue = function getMultipleSelectValue(options) {\n  return _toConsumableArray(options).filter(function (_ref2) {\n    var selected = _ref2.selected;\n    return selected;\n  }).map(function (_ref3) {\n    var value = _ref3.value;\n    return value;\n  });\n};\n\nvar isRadioInput = function isRadioInput(element) {\n  return element.type === 'radio';\n};\n\nvar isFileInput = function isFileInput(element) {\n  return element.type === 'file';\n};\n\nvar isCheckBoxInput = function isCheckBoxInput(element) {\n  return element.type === 'checkbox';\n};\n\nvar isMultipleSelect = function isMultipleSelect(element) {\n  return element.type === \"\".concat(SELECT, \"-multiple\");\n};\n\nvar defaultResult = {\n  value: false,\n  isValid: false\n};\nvar validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = function getCheckboxValue(options) {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      var values = options.filter(function (option) {\n        return option && option.ref.checked;\n      }).map(function (_ref4) {\n        var value = _ref4.ref.value;\n        return value;\n      });\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    var _options$0$ref = options[0].ref,\n        checked = _options$0$ref.checked,\n        value = _options$0$ref.value,\n        attributes = _options$0$ref.attributes;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || value === '' ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled) {\n  var field = fieldsRef.current[name];\n\n  if (field) {\n    var _field$ref = field.ref,\n        value = _field$ref.value,\n        disabled = _field$ref.disabled,\n        ref = field.ref;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n\n  return isDetached(element.parentNode);\n}\n\nvar isEmptyObject = function isEmptyObject(value) {\n  return isObject(value) && !Object.keys(value).length;\n};\n\nvar isBoolean = function isBoolean(value) {\n  return typeof value === 'boolean';\n};\n\nfunction baseGet(object, updatePath) {\n  var path = updatePath.slice(0, -1);\n  var length = path.length;\n  var index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nfunction unset(object, path) {\n  var updatePath = isKey(path) ? [path] : stringToPath(path);\n  var childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  var key = updatePath[updatePath.length - 1];\n  var previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (var k = 0; k < updatePath.slice(0, -1).length; k++) {\n    var index = -1;\n    var objectRef = undefined;\n    var currentPaths = updatePath.slice(0, -(k + 1));\n    var currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      var item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && !objectRef.filter(function (data) {\n        return isObject(data) && !isEmptyObject(data) || isBoolean(data);\n      }).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nvar isSameRef = function isSameRef(fieldValue, ref) {\n  return fieldValue && fieldValue.ref === ref;\n};\n\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\n  var ref = field.ref,\n      _field$ref2 = field.ref,\n      name = _field$ref2.name,\n      type = _field$ref2.type;\n  var fieldRef = fieldsRef.current[name];\n\n  if (!shouldUnregister) {\n    var value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n\n    if (!isUndefined(value)) {\n      set(shallowFieldsStateRef.current, name, value);\n    }\n  }\n\n  if (!type) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    var options = fieldRef.options;\n\n    if (Array.isArray(options) && options.length) {\n      compact(options).forEach(function (option, index) {\n        var ref = option.ref;\n\n        if (ref && isDetached(ref) && isSameRef(option, ref) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n          unset(options, \"[\".concat(index, \"]\"));\n        }\n      });\n\n      if (options && !compact(options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if (isDetached(ref) && isSameRef(fieldRef, ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n    delete fieldsRef.current[name];\n  }\n}\n\nfunction setFieldArrayDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\n  var index = -1;\n\n  while (++index < values.length) {\n    for (var key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setFieldArrayDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\n      } else {\n        get(defaultValues[index] || {}, key) === values[index][key] ? set(dirtyFields[index] || {}, key) : dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), _defineProperty({}, key, true));\n      }\n    }\n\n    !dirtyFields.length && parentNode && delete parentNode[parentName];\n  }\n\n  return dirtyFields.length ? dirtyFields : undefined;\n}\n\nvar isString = function isString(value) {\n  return typeof value === 'string';\n};\n\nvar isPrimitive = function isPrimitive(value) {\n  return isNullOrUndefined(value) || !isObjectType(value);\n};\n\nfunction deepMerge(target, source) {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (var key in source) {\n    var targetValue = target[key];\n    var sourceValue = source[key];\n\n    try {\n      target[key] = isObject(targetValue) && isObject(sourceValue) || Array.isArray(targetValue) && Array.isArray(sourceValue) ? deepMerge(targetValue, sourceValue) : sourceValue;\n    } catch (_a) {}\n  }\n\n  return target;\n}\n\nvar getFieldsValues = function getFieldsValues(fieldsRef, shallowFieldsStateRef, excludeDisabled, search) {\n  var output = {};\n\n  var _loop = function _loop(name) {\n    if (isUndefined(search) || (isString(search) ? name.startsWith(search) : Array.isArray(search) && search.find(function (data) {\n      return name.startsWith(data);\n    }))) {\n      output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\n    }\n  };\n\n  for (var name in fieldsRef.current) {\n    _loop(name);\n  }\n\n  return deepMerge(transformToNestObject(Object.assign({}, (shallowFieldsStateRef || {}).current || {})), transformToNestObject(output));\n};\n\nfunction deepEqual() {\n  var object1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var object2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var isErrorObject = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (isPrimitive(object1) && isPrimitive(object2)) {\n    return object1 === object2;\n  }\n\n  var keys1 = Object.keys(object1);\n  var keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (var _i = 0, _keys = keys1; _i < _keys.length; _i++) {\n    var key = _keys[_i];\n\n    if (!(isErrorObject && ['ref', 'context'].includes(key))) {\n      var val1 = object1[key];\n      var val2 = object2[key];\n\n      if ((isObject(val1) || Array.isArray(val1)) && (isObject(val2) || Array.isArray(val2)) ? !deepEqual(val1, val2, isErrorObject) : val1 !== val2) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction isErrorStateChanged(_ref5) {\n  var errors = _ref5.errors,\n      name = _ref5.name,\n      error = _ref5.error,\n      validFields = _ref5.validFields,\n      fieldsWithValidation = _ref5.fieldsWithValidation;\n  var isValid = isUndefined(error);\n  var previousError = get(errors, name);\n  return isValid && !!previousError || !isValid && !deepEqual(previousError, error, true) || isValid && get(fieldsWithValidation, name) && !get(validFields, name);\n}\n\nvar isRegex = function isRegex(value) {\n  return value instanceof RegExp;\n};\n\nvar isValueMessage = function isValueMessage(value) {\n  return isObject(value) && !isRegex(value);\n};\n\nvar getValueAndMessage = function getValueAndMessage(validationData) {\n  return isValueMessage(validationData) ? validationData : {\n    value: validationData,\n    message: ''\n  };\n};\n\nvar isFunction = function isFunction(value) {\n  return typeof value === 'function';\n};\n\nvar isMessage = function isMessage(value) {\n  return isString(value) || isObject(value) && isValidElement(value);\n};\n\nfunction getValidateError(result, ref) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'validate';\n\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type: type,\n      message: isMessage(result) ? result : '',\n      ref: ref\n    };\n  }\n}\n\nvar appendErrors = function appendErrors(name, validateAllFieldCriteria, errors, type, message) {\n  if (validateAllFieldCriteria) {\n    var error = errors[name];\n    return Object.assign(Object.assign({}, error), {\n      types: Object.assign(Object.assign({}, error && error.types ? error.types : {}), _defineProperty({}, type, message || true))\n    });\n  }\n\n  return {};\n};\n\nvar validateField = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fieldsRef, validateAllFieldCriteria, _ref6, shallowFieldsStateRef) {\n    var ref, _ref6$ref, type, value, options, required, maxLength, minLength, min, max, pattern, validate, fields, name, error, isRadio, isCheckBox, isRadioOrCheckbox, isEmpty, appendErrorsCurry, getMinMaxMessage, _ref8, requiredValue, requiredMessage, exceedMax, exceedMin, _getValueAndMessage, maxValue, maxMessage, _getValueAndMessage2, minValue, minMessage, valueNumber, valueDate, _getValueAndMessage3, maxLengthValue, maxLengthMessage, _getValueAndMessage4, minLengthValue, minLengthMessage, inputLength, _exceedMax, _exceedMin, _getValueAndMessage5, patternValue, patternMessage, fieldValue, validateRef, result, validateError, validationResult, _i2, _Object$entries, _Object$entries$_i, key, validateFunction, validateResult, _validateError;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            ref = _ref6.ref, _ref6$ref = _ref6.ref, type = _ref6$ref.type, value = _ref6$ref.value, options = _ref6.options, required = _ref6.required, maxLength = _ref6.maxLength, minLength = _ref6.minLength, min = _ref6.min, max = _ref6.max, pattern = _ref6.pattern, validate = _ref6.validate;\n            fields = fieldsRef.current;\n            name = ref.name;\n            error = {};\n            isRadio = isRadioInput(ref);\n            isCheckBox = isCheckBoxInput(ref);\n            isRadioOrCheckbox = isRadio || isCheckBox;\n            isEmpty = value === '';\n            appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n            getMinMaxMessage = function getMinMaxMessage(exceedMax, maxLengthMessage, minLengthMessage) {\n              var maxType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INPUT_VALIDATION_RULES.maxLength;\n              var minType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : INPUT_VALIDATION_RULES.minLength;\n              var message = exceedMax ? maxLengthMessage : minLengthMessage;\n              error[name] = Object.assign({\n                type: exceedMax ? maxType : minType,\n                message: message,\n                ref: ref\n              }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n            };\n\n            if (!(required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid))) {\n              _context.next = 16;\n              break;\n            }\n\n            _ref8 = isMessage(required) ? {\n              value: !!required,\n              message: required\n            } : getValueAndMessage(required), requiredValue = _ref8.value, requiredMessage = _ref8.message;\n\n            if (!requiredValue) {\n              _context.next = 16;\n              break;\n            }\n\n            error[name] = Object.assign({\n              type: INPUT_VALIDATION_RULES.required,\n              message: requiredMessage,\n              ref: isRadioOrCheckbox ? ((fields[name].options || [])[0] || {}).ref : ref\n            }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\n\n            if (validateAllFieldCriteria) {\n              _context.next = 16;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 16:\n            if (!(!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n              _context.next = 24;\n              break;\n            }\n\n            _getValueAndMessage = getValueAndMessage(max), maxValue = _getValueAndMessage.value, maxMessage = _getValueAndMessage.message;\n            _getValueAndMessage2 = getValueAndMessage(min), minValue = _getValueAndMessage2.value, minMessage = _getValueAndMessage2.message;\n\n            if (type === 'number' || !type && !isNaN(value)) {\n              valueNumber = ref.valueAsNumber || parseFloat(value);\n\n              if (!isNullOrUndefined(maxValue)) {\n                exceedMax = valueNumber > maxValue;\n              }\n\n              if (!isNullOrUndefined(minValue)) {\n                exceedMin = valueNumber < minValue;\n              }\n            } else {\n              valueDate = ref.valueAsDate || new Date(value);\n\n              if (isString(maxValue)) {\n                exceedMax = valueDate > new Date(maxValue);\n              }\n\n              if (isString(minValue)) {\n                exceedMin = valueDate < new Date(minValue);\n              }\n            }\n\n            if (!(exceedMax || exceedMin)) {\n              _context.next = 24;\n              break;\n            }\n\n            getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n            if (validateAllFieldCriteria) {\n              _context.next = 24;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 24:\n            if (!(isString(value) && !isEmpty && (maxLength || minLength))) {\n              _context.next = 34;\n              break;\n            }\n\n            _getValueAndMessage3 = getValueAndMessage(maxLength), maxLengthValue = _getValueAndMessage3.value, maxLengthMessage = _getValueAndMessage3.message;\n            _getValueAndMessage4 = getValueAndMessage(minLength), minLengthValue = _getValueAndMessage4.value, minLengthMessage = _getValueAndMessage4.message;\n            inputLength = value.toString().length;\n            _exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n            _exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n            if (!(_exceedMax || _exceedMin)) {\n              _context.next = 34;\n              break;\n            }\n\n            getMinMaxMessage(!!_exceedMax, maxLengthMessage, minLengthMessage);\n\n            if (validateAllFieldCriteria) {\n              _context.next = 34;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 34:\n            if (!(pattern && !isEmpty)) {\n              _context.next = 40;\n              break;\n            }\n\n            _getValueAndMessage5 = getValueAndMessage(pattern), patternValue = _getValueAndMessage5.value, patternMessage = _getValueAndMessage5.message;\n\n            if (!(isRegex(patternValue) && !patternValue.test(value))) {\n              _context.next = 40;\n              break;\n            }\n\n            error[name] = Object.assign({\n              type: INPUT_VALIDATION_RULES.pattern,\n              message: patternMessage,\n              ref: ref\n            }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\n\n            if (validateAllFieldCriteria) {\n              _context.next = 40;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 40:\n            if (!validate) {\n              _context.next = 73;\n              break;\n            }\n\n            fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n            validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n            if (!isFunction(validate)) {\n              _context.next = 54;\n              break;\n            }\n\n            _context.next = 46;\n            return validate(fieldValue);\n\n          case 46:\n            result = _context.sent;\n            validateError = getValidateError(result, validateRef);\n\n            if (!validateError) {\n              _context.next = 52;\n              break;\n            }\n\n            error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n            if (validateAllFieldCriteria) {\n              _context.next = 52;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 52:\n            _context.next = 73;\n            break;\n\n          case 54:\n            if (!isObject(validate)) {\n              _context.next = 73;\n              break;\n            }\n\n            validationResult = {};\n            _i2 = 0, _Object$entries = Object.entries(validate);\n\n          case 57:\n            if (!(_i2 < _Object$entries.length)) {\n              _context.next = 69;\n              break;\n            }\n\n            _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), key = _Object$entries$_i[0], validateFunction = _Object$entries$_i[1];\n\n            if (!(!isEmptyObject(validationResult) && !validateAllFieldCriteria)) {\n              _context.next = 61;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 69);\n\n          case 61:\n            _context.next = 63;\n            return validateFunction(fieldValue);\n\n          case 63:\n            validateResult = _context.sent;\n            _validateError = getValidateError(validateResult, validateRef, key);\n\n            if (_validateError) {\n              validationResult = Object.assign(Object.assign({}, _validateError), appendErrorsCurry(key, _validateError.message));\n\n              if (validateAllFieldCriteria) {\n                error[name] = validationResult;\n              }\n            }\n\n          case 66:\n            _i2++;\n            _context.next = 57;\n            break;\n\n          case 69:\n            if (isEmptyObject(validationResult)) {\n              _context.next = 73;\n              break;\n            }\n\n            error[name] = Object.assign({\n              ref: validateRef\n            }, validationResult);\n\n            if (validateAllFieldCriteria) {\n              _context.next = 73;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 73:\n            return _context.abrupt(\"return\", error);\n\n          case 74:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function validateField(_x, _x2, _x3, _x4) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nvar getPath = function getPath(path, values) {\n  var getInnerPath = function getInnerPath(key, value, isObject) {\n    var pathWithIndex = isObject ? \"\".concat(path, \".\").concat(key) : \"\".concat(path, \"[\").concat(key, \"]\");\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return Object.entries(values).map(function (_ref9) {\n    var _ref10 = _slicedToArray(_ref9, 2),\n        key = _ref10[0],\n        value = _ref10[1];\n\n    return getInnerPath(key, value, isObject(values));\n  }).flat(Infinity);\n};\n\nvar assignWatchFields = function assignWatchFields(fieldValues, fieldName, watchFields, inputValue, isSingleField) {\n  var value;\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || Array.isArray(value)) {\n      getPath(fieldName, value).forEach(function (name) {\n        return watchFields.add(name);\n      });\n    }\n  }\n\n  return isUndefined(value) ? isSingleField ? inputValue : get(inputValue, fieldName) : value;\n};\n\nvar skipValidation = function skipValidation(_ref11) {\n  var isOnBlur = _ref11.isOnBlur,\n      isOnChange = _ref11.isOnChange,\n      isOnTouch = _ref11.isOnTouch,\n      isTouched = _ref11.isTouched,\n      isReValidateOnBlur = _ref11.isReValidateOnBlur,\n      isReValidateOnChange = _ref11.isReValidateOnChange,\n      isBlurEvent = _ref11.isBlurEvent,\n      isSubmitted = _ref11.isSubmitted,\n      isOnAll = _ref11.isOnAll;\n\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n\n  return true;\n};\n\nvar getFieldArrayParentName = function getFieldArrayParentName(name) {\n  return name.substring(0, name.indexOf('['));\n};\n\nvar isMatchFieldArrayName = function isMatchFieldArrayName(name, searchName) {\n  return RegExp(\"^\".concat(searchName, \"[\\\\d+]\").replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\n};\n\nvar isNameInFieldArray = function isNameInFieldArray(names, name) {\n  return _toConsumableArray(names).some(function (current) {\n    return isMatchFieldArrayName(name, current);\n  });\n};\n\nvar isSelectInput = function isSelectInput(element) {\n  return element.type === \"\".concat(SELECT, \"-one\");\n};\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\n  var observer = new MutationObserver(function () {\n    for (var _i3 = 0, _Object$values = Object.values(fieldsRef.current); _i3 < _Object$values.length; _i3++) {\n      var field = _Object$values[_i3];\n\n      if (field && field.options) {\n        var _iterator = _createForOfIteratorHelper(field.options),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var option = _step.value;\n\n            if (option && option.ref && isDetached(option.ref)) {\n              removeFieldEventListenerAndRef(field);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nfunction cloneObject(data, isWeb) {\n  var copy;\n\n  if (isPrimitive(data) || isWeb && data instanceof File) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n\n    var _iterator2 = _createForOfIteratorHelper(data),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var item = _step2.value;\n        copy.add(item);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n\n    var _iterator3 = _createForOfIteratorHelper(data.keys()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var key = _step3.value;\n        copy.set(key, cloneObject(data.get(key), isWeb));\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (var _key in data) {\n    copy[_key] = cloneObject(data[_key], isWeb);\n  }\n\n  return copy;\n}\n\nvar modeChecker = function modeChecker(mode) {\n  return {\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\n    isOnChange: mode === VALIDATION_MODE.onChange,\n    isOnAll: mode === VALIDATION_MODE.all,\n    isOnTouch: mode === VALIDATION_MODE.onTouched\n  };\n};\n\nvar isRadioOrCheckboxFunction = function isRadioOrCheckboxFunction(ref) {\n  return isRadioInput(ref) || isCheckBoxInput(ref);\n};\n\nvar isWindowUndefined = typeof window === UNDEFINED;\nvar isWeb = typeof document !== UNDEFINED && !isWindowUndefined && !isUndefined(window.HTMLElement);\nvar isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nfunction useForm() {\n  var _ref12 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref12$mode = _ref12.mode,\n      mode = _ref12$mode === void 0 ? VALIDATION_MODE.onSubmit : _ref12$mode,\n      _ref12$reValidateMode = _ref12.reValidateMode,\n      reValidateMode = _ref12$reValidateMode === void 0 ? VALIDATION_MODE.onChange : _ref12$reValidateMode,\n      resolver = _ref12.resolver,\n      context = _ref12.context,\n      _ref12$defaultValues = _ref12.defaultValues,\n      defaultValues = _ref12$defaultValues === void 0 ? {} : _ref12$defaultValues,\n      _ref12$shouldFocusErr = _ref12.shouldFocusError,\n      shouldFocusError = _ref12$shouldFocusErr === void 0 ? true : _ref12$shouldFocusErr,\n      _ref12$shouldUnregist = _ref12.shouldUnregister,\n      shouldUnregister = _ref12$shouldUnregist === void 0 ? true : _ref12$shouldUnregist,\n      criteriaMode = _ref12.criteriaMode;\n\n  var fieldsRef = useRef({});\n  var fieldArrayDefaultValuesRef = useRef({});\n  var watchFieldsRef = useRef(new Set());\n  var useWatchFieldsRef = useRef({});\n  var useWatchRenderFunctionsRef = useRef({});\n  var fieldsWithValidationRef = useRef({});\n  var validFieldsRef = useRef({});\n  var defaultValuesRef = useRef(defaultValues);\n  var defaultValuesAtRenderRef = useRef({});\n  var isUnMount = useRef(false);\n  var isWatchAllRef = useRef(false);\n  var handleChangeRef = useRef();\n  var shallowFieldsStateRef = useRef(shouldUnregister ? {} : cloneObject(defaultValues, isWeb));\n  var resetFieldArrayFunctionRef = useRef({});\n  var contextRef = useRef(context);\n  var resolverRef = useRef(resolver);\n  var fieldArrayNamesRef = useRef(new Set());\n  var modeRef = useRef(modeChecker(mode));\n  var _modeRef$current = modeRef.current,\n      isOnSubmit = _modeRef$current.isOnSubmit,\n      isOnTouch = _modeRef$current.isOnTouch;\n  var isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n\n  var _useState = useState({\n    isDirty: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {}\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      formState = _useState2[0],\n      setFormState = _useState2[1];\n\n  var readFormStateRef = useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  var formStateRef = useRef(formState);\n  var observerRef = useRef();\n  var _useRef$current = useRef(modeChecker(reValidateMode)).current,\n      isReValidateOnBlur = _useRef$current.isOnBlur,\n      isReValidateOnChange = _useRef$current.isOnChange;\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n  var updateFormState = useCallback(function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return !isUnMount.current && setFormState(Object.assign(Object.assign({}, formStateRef.current), state));\n  }, []);\n  var shouldRenderBaseOnError = useCallback(function (name, error) {\n    var shouldRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var isValid = arguments.length > 4 ? arguments[4] : undefined;\n    var shouldReRender = shouldRender || isErrorStateChanged({\n      errors: formStateRef.current.errors,\n      error: error,\n      name: name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    var previousError = get(formStateRef.current.errors, name);\n\n    if (error) {\n      unset(validFieldsRef.current, name);\n      shouldReRender = shouldReRender || !previousError || !deepEqual(previousError, error, true);\n      set(formStateRef.current.errors, name, error);\n    } else {\n      if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n        set(validFieldsRef.current, name, true);\n        shouldReRender = shouldReRender || previousError;\n      }\n\n      unset(formStateRef.current.errors, name);\n    }\n\n    if (shouldReRender && !isNullOrUndefined(shouldRender) || !isEmptyObject(state)) {\n      updateFormState(Object.assign(Object.assign(Object.assign({}, state), {\n        errors: formStateRef.current.errors\n      }), resolverRef.current ? {\n        isValid: !!isValid\n      } : {}));\n    }\n  }, []);\n  var setFieldValue = useCallback(function (name, rawValue) {\n    var _fieldsRef$current$na = fieldsRef.current[name],\n        ref = _fieldsRef$current$na.ref,\n        options = _fieldsRef$current$na.options;\n    var value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(ref) && options) {\n      options.forEach(function (_ref13) {\n        var radioRef = _ref13.ref;\n        return radioRef.checked = radioRef.value === value;\n      });\n    } else if (isFileInput(ref) && !isString(value)) {\n      ref.files = value;\n    } else if (isMultipleSelect(ref)) {\n      _toConsumableArray(ref.options).forEach(function (selectRef) {\n        return selectRef.selected = value.includes(selectRef.value);\n      });\n    } else if (isCheckBoxInput(ref) && options) {\n      options.length > 1 ? options.forEach(function (_ref14) {\n        var checkboxRef = _ref14.ref;\n        return checkboxRef.checked = Array.isArray(value) ? !!value.find(function (data) {\n          return data === checkboxRef.value;\n        }) : value === checkboxRef.value;\n      }) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n  }, []);\n\n  var isFormDirty = function isFormDirty() {\n    return !deepEqual(getValues(), isEmptyObject(defaultValuesRef.current) ? defaultValuesAtRenderRef.current : defaultValuesRef.current) || !isEmptyObject(formStateRef.current.dirtyFields);\n  };\n\n  var updateAndGetDirtyState = useCallback(function (name) {\n    var shouldRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) {\n      var isFieldDirty = !deepEqual(get(defaultValuesAtRenderRef.current, name), getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      var isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n      var previousIsDirty = formStateRef.current.isDirty;\n      isFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);\n      var state = {\n        isDirty: isFormDirty(),\n        dirtyFields: formStateRef.current.dirtyFields\n      };\n      var isChanged = readFormStateRef.current.isDirty && previousIsDirty !== state.isDirty || readFormStateRef.current.dirtyFields && isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name);\n\n      if (isChanged && shouldRender) {\n        formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\n        updateFormState(Object.assign({}, state));\n      }\n\n      return isChanged ? state : {};\n    }\n\n    return {};\n  }, []);\n  var executeValidation = useCallback( /*#__PURE__*/function () {\n    var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, skipReRender) {\n      var _error;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!fieldsRef.current[name]) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 3;\n              return validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef);\n\n            case 3:\n              _context2.t0 = name;\n              _error = _context2.sent[_context2.t0];\n              shouldRenderBaseOnError(name, _error, skipReRender);\n              return _context2.abrupt(\"return\", isUndefined(_error));\n\n            case 7:\n              return _context2.abrupt(\"return\", false);\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x5, _x6) {\n      return _ref15.apply(this, arguments);\n    };\n  }(), [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  var executeSchemaOrResolverValidation = useCallback( /*#__PURE__*/function () {\n    var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(names) {\n      var _yield$resolverRef$cu, errors, previousFormIsValid, isInputsValid, _error2;\n\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n\n            case 2:\n              _yield$resolverRef$cu = _context3.sent;\n              errors = _yield$resolverRef$cu.errors;\n              previousFormIsValid = formStateRef.current.isValid;\n\n              if (!Array.isArray(names)) {\n                _context3.next = 11;\n                break;\n              }\n\n              isInputsValid = names.map(function (name) {\n                var error = get(errors, name);\n                error ? set(formStateRef.current.errors, name, error) : unset(formStateRef.current.errors, name);\n                return !error;\n              }).every(Boolean);\n              updateFormState({\n                isValid: isEmptyObject(errors),\n                errors: formStateRef.current.errors\n              });\n              return _context3.abrupt(\"return\", isInputsValid);\n\n            case 11:\n              _error2 = get(errors, names);\n              shouldRenderBaseOnError(names, _error2, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\n              return _context3.abrupt(\"return\", !_error2);\n\n            case 14:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x7) {\n      return _ref16.apply(this, arguments);\n    };\n  }(), [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  var trigger = useCallback( /*#__PURE__*/function () {\n    var _ref17 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(name) {\n      var fields, result;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              fields = name || Object.keys(fieldsRef.current);\n\n              if (!resolverRef.current) {\n                _context5.next = 3;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", executeSchemaOrResolverValidation(fields));\n\n            case 3:\n              if (!Array.isArray(fields)) {\n                _context5.next = 10;\n                break;\n              }\n\n              !name && (formStateRef.current.errors = {});\n              _context5.next = 7;\n              return Promise.all(fields.map( /*#__PURE__*/function () {\n                var _ref18 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(data) {\n                  return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          _context4.next = 2;\n                          return executeValidation(data, null);\n\n                        case 2:\n                          return _context4.abrupt(\"return\", _context4.sent);\n\n                        case 3:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                }));\n\n                return function (_x9) {\n                  return _ref18.apply(this, arguments);\n                };\n              }()));\n\n            case 7:\n              result = _context5.sent;\n              updateFormState();\n              return _context5.abrupt(\"return\", result.every(Boolean));\n\n            case 10:\n              _context5.next = 12;\n              return executeValidation(fields, readFormStateRef.current.isValid);\n\n            case 12:\n              return _context5.abrupt(\"return\", _context5.sent);\n\n            case 13:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    return function (_x8) {\n      return _ref17.apply(this, arguments);\n    };\n  }(), [executeSchemaOrResolverValidation, executeValidation]);\n  var setInternalValues = useCallback(function (name, value, _ref19) {\n    var shouldDirty = _ref19.shouldDirty,\n        shouldValidate = _ref19.shouldValidate;\n    var data = {};\n    set(data, name, value);\n\n    var _iterator4 = _createForOfIteratorHelper(getPath(name, value)),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var fieldName = _step4.value;\n\n        if (fieldsRef.current[fieldName]) {\n          setFieldValue(fieldName, get(data, fieldName));\n          shouldDirty && updateAndGetDirtyState(fieldName);\n          shouldValidate && trigger(fieldName);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }, [trigger, setFieldValue, updateAndGetDirtyState]);\n  var setInternalValue = useCallback(function (name, value) {\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (fieldsRef.current[name]) {\n      setFieldValue(name, value);\n      config.shouldDirty && updateAndGetDirtyState(name);\n    } else if (!isPrimitive(value)) {\n      setInternalValues(name, value, config);\n\n      if (fieldArrayNamesRef.current.has(name)) {\n        fieldArrayDefaultValuesRef.current[name] = value;\n        resetFieldArrayFunctionRef.current[name](_defineProperty({}, name, value));\n\n        if ((readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && config.shouldDirty) {\n          set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n          updateFormState({\n            isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), _defineProperty({}, name, value)), defaultValuesRef.current),\n            dirtyFields: formStateRef.current.dirtyFields\n          });\n        }\n      }\n    }\n\n    !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n  }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\n\n  var isFieldWatched = function isFieldWatched(name) {\n    return isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n  };\n\n  var renderWatchedInputs = function renderWatchedInputs(name) {\n    var found = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (var key in useWatchFieldsRef.current) {\n        if (!name || !useWatchFieldsRef.current[key].size || useWatchFieldsRef.current[key].has(name) || useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue(name, value, config) {\n    setInternalValue(name, value, config);\n    isFieldWatched(name) && updateFormState();\n    renderWatchedInputs(name);\n    (config || {}).shouldValidate && trigger(name);\n  }\n\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : /*#__PURE__*/function () {\n    var _ref21 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref20) {\n      var type, target, name, field, error, isValid, isBlurEvent, shouldSkipValidation, state, shouldRender, _yield$resolverRef$cu2, errors, previousFormIsValid, parentNodeName, currentError;\n\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              type = _ref20.type, target = _ref20.target;\n              name = target.name;\n              field = fieldsRef.current[name];\n\n              if (!field) {\n                _context6.next = 30;\n                break;\n              }\n\n              isBlurEvent = type === EVENTS.BLUR;\n              shouldSkipValidation = skipValidation(Object.assign({\n                isBlurEvent: isBlurEvent,\n                isReValidateOnChange: isReValidateOnChange,\n                isReValidateOnBlur: isReValidateOnBlur,\n                isTouched: !!get(formStateRef.current.touched, name),\n                isSubmitted: formStateRef.current.isSubmitted\n              }, modeRef.current));\n              state = updateAndGetDirtyState(name, false);\n              shouldRender = !isEmptyObject(state) || isFieldWatched(name);\n\n              if (isBlurEvent && !get(formStateRef.current.touched, name) && readFormStateRef.current.touched) {\n                set(formStateRef.current.touched, name, true);\n                state = Object.assign(Object.assign({}, state), {\n                  touched: formStateRef.current.touched\n                });\n              }\n\n              if (!shouldSkipValidation) {\n                _context6.next = 12;\n                break;\n              }\n\n              renderWatchedInputs(name);\n              return _context6.abrupt(\"return\", (!isEmptyObject(state) || shouldRender && isEmptyObject(state)) && updateFormState(state));\n\n            case 12:\n              if (!resolverRef.current) {\n                _context6.next = 24;\n                break;\n              }\n\n              _context6.next = 15;\n              return resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n\n            case 15:\n              _yield$resolverRef$cu2 = _context6.sent;\n              errors = _yield$resolverRef$cu2.errors;\n              previousFormIsValid = formStateRef.current.isValid;\n              error = get(errors, name);\n\n              if (!error && resolverRef.current) {\n                parentNodeName = name.substring(0, name.lastIndexOf('.') > name.lastIndexOf('[') ? name.lastIndexOf('.') : name.lastIndexOf('['));\n                currentError = get(errors, parentNodeName, {});\n                currentError.type && currentError.message && (error = currentError);\n\n                if (parentNodeName && (currentError || get(formStateRef.current.errors, parentNodeName))) {\n                  name = parentNodeName;\n                }\n              }\n\n              isValid = isEmptyObject(errors);\n\n              if (previousFormIsValid !== isValid) {\n                shouldRender = true;\n              }\n\n              _context6.next = 28;\n              break;\n\n            case 24:\n              _context6.next = 26;\n              return validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\n\n            case 26:\n              _context6.t0 = name;\n              error = _context6.sent[_context6.t0];\n\n            case 28:\n              renderWatchedInputs(name);\n              shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n\n            case 30:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n\n    return function (_x10) {\n      return _ref21.apply(this, arguments);\n    };\n  }();\n\n  function setFieldArrayDefaultValues(data) {\n    if (!shouldUnregister) {\n      var copy = cloneObject(data, isWeb);\n\n      var _iterator5 = _createForOfIteratorHelper(fieldArrayNamesRef.current),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var value = _step5.value;\n\n          if (isKey(value) && !copy[value]) {\n            copy = Object.assign(Object.assign({}, copy), _defineProperty({}, value, []));\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return copy;\n    }\n\n    return data;\n  }\n\n  function getValues(payload) {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (Array.isArray(payload)) {\n      var data = {};\n\n      var _iterator6 = _createForOfIteratorHelper(payload),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _name = _step6.value;\n          set(data, _name, getFieldValue(fieldsRef, _name, shallowFieldsStateRef));\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return data;\n    }\n\n    return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, shallowFieldsStateRef));\n  }\n\n  var validateResolver = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n    var values,\n        _yield$resolverRef$cu3,\n        errors,\n        isValid,\n        _args7 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            values = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};\n            _context7.next = 3;\n            return resolverRef.current(Object.assign(Object.assign(Object.assign({}, defaultValuesRef.current), getValues()), values), contextRef.current, isValidateAllFieldCriteria);\n\n          case 3:\n            _yield$resolverRef$cu3 = _context7.sent;\n            errors = _yield$resolverRef$cu3.errors;\n            isValid = isEmptyObject(errors);\n            formStateRef.current.isValid !== isValid && updateFormState({\n              isValid: isValid\n            });\n\n          case 7:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  })), [isValidateAllFieldCriteria]);\n  var removeFieldEventListener = useCallback(function (field, forceDelete) {\n    return findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete);\n  }, [shouldUnregister]);\n\n  var updateWatchedValue = function updateWatchedValue(name) {\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else if (watchFieldsRef) {\n      var shouldRenderUseWatch = true;\n\n      var _iterator7 = _createForOfIteratorHelper(watchFieldsRef.current),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var watchField = _step7.value;\n\n          if (watchField.startsWith(name)) {\n            updateFormState();\n            shouldRenderUseWatch = false;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      shouldRenderUseWatch && renderWatchedInputs(name);\n    }\n  };\n\n  var removeFieldEventListenerAndRef = useCallback(function (field, forceDelete) {\n    if (field) {\n      removeFieldEventListener(field, forceDelete);\n\n      if (shouldUnregister && !compact(field.options || []).length) {\n        unset(defaultValuesAtRenderRef.current, field.ref.name);\n        unset(validFieldsRef.current, field.ref.name);\n        unset(fieldsWithValidationRef.current, field.ref.name);\n        unset(formStateRef.current.errors, field.ref.name);\n        set(formStateRef.current.dirtyFields, field.ref.name, true);\n        updateFormState({\n          errors: formStateRef.current.errors,\n          isDirty: isFormDirty(),\n          dirtyFields: formStateRef.current.dirtyFields\n        });\n        readFormStateRef.current.isValid && resolverRef.current && validateResolver();\n        updateWatchedValue(field.ref.name);\n      }\n    }\n  }, [validateResolver, removeFieldEventListener]);\n\n  function clearErrors(name) {\n    name && (Array.isArray(name) ? name : [name]).forEach(function (inputName) {\n      return fieldsRef.current[inputName] ? isKey(inputName) ? delete formStateRef.current.errors[inputName] : set(formStateRef.current.errors, inputName, undefined) : unset(formStateRef.current.errors, inputName);\n    });\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {}\n    });\n  }\n\n  function setError(name, error) {\n    var ref = (fieldsRef.current[name] || {}).ref;\n    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), {\n      ref: ref\n    }));\n    updateFormState({\n      isValid: false,\n      errors: formStateRef.current.errors\n    });\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  var watchInternal = useCallback(function (fieldNames, defaultValue, watchId) {\n    var watchFields = watchId ? useWatchFieldsRef.current[watchId] : watchFieldsRef.current;\n    var combinedDefaultValues = isUndefined(defaultValue) ? defaultValuesRef.current : defaultValue;\n    var fieldValues = getFieldsValues(fieldsRef, shallowFieldsStateRef, false, fieldNames);\n\n    if (isString(fieldNames)) {\n      return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(defaultValue) ? get(combinedDefaultValues, fieldNames) : defaultValue, true);\n    }\n\n    if (Array.isArray(fieldNames)) {\n      return fieldNames.reduce(function (previous, name) {\n        return Object.assign(Object.assign({}, previous), _defineProperty({}, name, assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)));\n      }, {});\n    }\n\n    isWatchAllRef.current = isUndefined(watchId);\n    return transformToNestObject(!isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues);\n  }, []);\n\n  function watch(fieldNames, defaultValue) {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(name) {\n    var _iterator8 = _createForOfIteratorHelper(Array.isArray(name) ? name : [name]),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var fieldName = _step8.value;\n        removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n  }\n\n  function registerFieldRef(ref) {\n    var validateOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn(' Field is missing `name` attribute', ref, \"https://react-hook-form.com/api#useForm\");\n      }\n\n      if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) && !RegExp(\"^\".concat(ref.name.split(/\\[\\d+\\]$/)[0], \"[\\\\d+].\\\\w+\").replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(ref.name)) {\n        return console.warn(' `name` prop should be in object shape: name=\"test[index].name\"', ref, 'https://react-hook-form.com/api#useFieldArray');\n      }\n    }\n\n    var name = ref.name,\n        type = ref.type,\n        value = ref.value;\n    var fieldRefAndValidationOptions = Object.assign({\n      ref: ref\n    }, validateOptions);\n    var fields = fieldsRef.current;\n    var isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    var isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n    var compareRef = function compareRef(currentRef) {\n      return isWeb && (!isHTMLElement(ref) || currentRef === ref);\n    };\n\n    var field = fields[name];\n    var isEmptyDefaultValue = true;\n    var defaultValue;\n\n    if (field && (isRadioOrCheckbox ? Array.isArray(field.options) && compact(field.options).find(function (option) {\n      return value === option.ref.value && compareRef(option.ref);\n    }) : compareRef(field.ref))) {\n      fields[name] = Object.assign(Object.assign({}, field), validateOptions);\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox ? Object.assign({\n        options: [].concat(_toConsumableArray(compact(field && field.options || [])), [{\n          ref: ref\n        }]),\n        ref: {\n          type: type,\n          name: name\n        }\n      }, validateOptions) : Object.assign({}, fieldRefAndValidationOptions);\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n    var isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(isEmptyUnmountFields ? defaultValuesRef.current : shallowFieldsStateRef.current, name);\n      isEmptyDefaultValue = isUndefined(defaultValue);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    if (!isEmptyObject(validateOptions)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then(function (error) {\n          var previousFormIsValid = formStateRef.current.isValid;\n          isEmptyObject(error) ? set(validFieldsRef.current, name, true) : unset(validFieldsRef.current, name);\n\n          if (previousFormIsValid !== isEmptyObject(error)) {\n            updateFormState();\n          }\n        });\n      }\n    }\n\n    if (!defaultValuesAtRenderRef.current[name] && !(isFieldArray && isEmptyDefaultValue)) {\n      var fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n      set(defaultValuesAtRenderRef.current, name, isEmptyDefaultValue ? isObject(fieldValue) ? Object.assign({}, fieldValue) : fieldValue : defaultValue);\n      !isFieldArray && unset(formStateRef.current.dirtyFields, name);\n    }\n\n    if (type) {\n      attachEventListeners(isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\n    }\n  }\n\n  function register(refOrValidationOptions, rules) {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldRef({\n          name: refOrValidationOptions\n        }, rules);\n      } else if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\n        registerFieldRef(refOrValidationOptions, rules);\n      } else {\n        return function (ref) {\n          return ref && registerFieldRef(ref, refOrValidationOptions);\n        };\n      }\n    }\n  }\n\n  var handleSubmit = useCallback(function (onValid, onInvalid) {\n    return /*#__PURE__*/function () {\n      var _ref23 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(e) {\n        var fieldErrors, fieldValues, _yield$resolverRef$cu4, errors, values, _i4, _Object$values2, field, _name2, fieldError;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (e && e.preventDefault) {\n                  e.preventDefault();\n                  e.persist();\n                }\n\n                fieldErrors = {};\n                fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, shallowFieldsStateRef, true));\n                readFormStateRef.current.isSubmitting && updateFormState({\n                  isSubmitting: true\n                });\n                _context8.prev = 4;\n\n                if (!resolverRef.current) {\n                  _context8.next = 15;\n                  break;\n                }\n\n                _context8.next = 8;\n                return resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\n\n              case 8:\n                _yield$resolverRef$cu4 = _context8.sent;\n                errors = _yield$resolverRef$cu4.errors;\n                values = _yield$resolverRef$cu4.values;\n                formStateRef.current.errors = fieldErrors = errors;\n                fieldValues = values;\n                _context8.next = 27;\n                break;\n\n              case 15:\n                _i4 = 0, _Object$values2 = Object.values(fieldsRef.current);\n\n              case 16:\n                if (!(_i4 < _Object$values2.length)) {\n                  _context8.next = 27;\n                  break;\n                }\n\n                field = _Object$values2[_i4];\n\n                if (!field) {\n                  _context8.next = 24;\n                  break;\n                }\n\n                _name2 = field.ref.name;\n                _context8.next = 22;\n                return validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\n\n              case 22:\n                fieldError = _context8.sent;\n\n                if (fieldError[_name2]) {\n                  set(fieldErrors, _name2, fieldError[_name2]);\n                  unset(validFieldsRef.current, _name2);\n                } else if (get(fieldsWithValidationRef.current, _name2)) {\n                  unset(formStateRef.current.errors, _name2);\n                  set(validFieldsRef.current, _name2, true);\n                }\n\n              case 24:\n                _i4++;\n                _context8.next = 16;\n                break;\n\n              case 27:\n                if (!(isEmptyObject(fieldErrors) && Object.keys(formStateRef.current.errors).every(function (name) {\n                  return name in fieldsRef.current;\n                }))) {\n                  _context8.next = 33;\n                  break;\n                }\n\n                updateFormState({\n                  errors: {},\n                  isSubmitting: true\n                });\n                _context8.next = 31;\n                return onValid(fieldValues, e);\n\n              case 31:\n                _context8.next = 39;\n                break;\n\n              case 33:\n                formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\n                _context8.t0 = onInvalid;\n\n                if (!_context8.t0) {\n                  _context8.next = 38;\n                  break;\n                }\n\n                _context8.next = 38;\n                return onInvalid(formStateRef.current.errors, e);\n\n              case 38:\n                shouldFocusError && focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\n\n              case 39:\n                _context8.prev = 39;\n                updateFormState({\n                  isSubmitted: true,\n                  isSubmitting: false,\n                  isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n                  errors: formStateRef.current.errors,\n                  submitCount: formStateRef.current.submitCount + 1\n                });\n                return _context8.finish(39);\n\n              case 42:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, null, [[4,, 39, 42]]);\n      }));\n\n      return function (_x11) {\n        return _ref23.apply(this, arguments);\n      };\n    }();\n  }, [shouldFocusError, isValidateAllFieldCriteria]);\n\n  var resetRefs = function resetRefs(_ref24) {\n    var errors = _ref24.errors,\n        isDirty = _ref24.isDirty,\n        isSubmitted = _ref24.isSubmitted,\n        touched = _ref24.touched,\n        isValid = _ref24.isValid,\n        submitCount = _ref24.submitCount,\n        dirtyFields = _ref24.dirtyFields;\n\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    defaultValuesAtRenderRef.current = {};\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n    updateFormState({\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: isValid ? formStateRef.current.isValid : false,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false\n    });\n  };\n\n  var reset = function reset(values) {\n    var omitResetState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (isWeb) {\n      for (var _i5 = 0, _Object$values3 = Object.values(fieldsRef.current); _i5 < _Object$values3.length; _i5++) {\n        var field = _Object$values3[_i5];\n\n        if (field) {\n          var _ref25 = field.ref,\n              options = field.options;\n          var inputRef = isRadioOrCheckboxFunction(_ref25) && Array.isArray(options) ? options[0].ref : _ref25;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n    defaultValuesRef.current = cloneObject(values || defaultValuesRef.current, isWeb);\n    values && renderWatchedInputs('');\n    Object.values(resetFieldArrayFunctionRef.current).forEach(function (resetFieldArray) {\n      return isFunction(resetFieldArray) && resetFieldArray();\n    });\n    shallowFieldsStateRef.current = shouldUnregister ? {} : cloneObject(values, isWeb) || {};\n    resetRefs(omitResetState);\n  };\n\n  useEffect(function () {\n    isUnMount.current = false;\n    resolver && readFormStateRef.current.isValid && validateResolver();\n    observerRef.current = observerRef.current || !isWeb ? observerRef.current : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n    return function () {\n      isUnMount.current = true;\n      observerRef.current && observerRef.current.disconnect();\n      shallowFieldsStateRef.current = {};\n\n      if (process.env.NODE_ENV !== 'production') {\n        return;\n      }\n\n      Object.values(fieldsRef.current).forEach(function (field) {\n        return removeFieldEventListenerAndRef(field, true);\n      });\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid = deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) && isEmptyObject(formStateRef.current.errors);\n  }\n\n  var commonProps = {\n    trigger: trigger,\n    setValue: useCallback(setValue, [setInternalValue, trigger]),\n    getValues: useCallback(getValues, []),\n    register: useCallback(register, [defaultValuesRef.current]),\n    unregister: useCallback(unregister, [])\n  };\n  var control = Object.assign({\n    updateWatchedValue: updateWatchedValue,\n    shouldUnregister: shouldUnregister,\n    removeFieldEventListener: removeFieldEventListener,\n    watchInternal: watchInternal,\n    mode: modeRef.current,\n    reValidateMode: {\n      isReValidateOnBlur: isReValidateOnBlur,\n      isReValidateOnChange: isReValidateOnChange\n    },\n    fieldsRef: fieldsRef,\n    resetFieldArrayFunctionRef: resetFieldArrayFunctionRef,\n    useWatchFieldsRef: useWatchFieldsRef,\n    useWatchRenderFunctionsRef: useWatchRenderFunctionsRef,\n    fieldArrayDefaultValuesRef: fieldArrayDefaultValuesRef,\n    validFieldsRef: validFieldsRef,\n    fieldsWithValidationRef: fieldsWithValidationRef,\n    fieldArrayNamesRef: fieldArrayNamesRef,\n    readFormStateRef: readFormStateRef,\n    formStateRef: formStateRef,\n    defaultValuesRef: defaultValuesRef,\n    shallowFieldsStateRef: shallowFieldsStateRef,\n    updateFormState: updateFormState,\n    validateResolver: resolver ? validateResolver : undefined\n  }, commonProps);\n  return Object.assign({\n    watch: watch,\n    control: control,\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: function get(obj, prop) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (prop === 'isValid' && isOnSubmit) {\n            console.warn(' `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\n          }\n        }\n\n        if (prop in obj) {\n          readFormStateRef.current[prop] = true;\n          return obj[prop];\n        }\n\n        return undefined;\n      }\n    }) : formState,\n    handleSubmit: handleSubmit,\n    reset: useCallback(reset, []),\n    clearErrors: useCallback(clearErrors, []),\n    setError: useCallback(setError, []),\n    errors: formState.errors\n  }, commonProps);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nvar FormContext = createContext(null);\nFormContext.displayName = 'RHFContext';\n\nvar useFormContext = function useFormContext() {\n  return useContext(FormContext);\n};\n\nvar FormProvider = function FormProvider(_a) {\n  var children = _a.children,\n      props = __rest(_a, [\"children\"]);\n\n  return createElement(FormContext.Provider, {\n    value: Object.assign({}, props)\n  }, children);\n};\n\nvar generateId = function generateId() {\n  var d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nvar removeAt = function removeAt(data, index) {\n  return [].concat(_toConsumableArray(data.slice(0, index)), _toConsumableArray(data.slice(index + 1)));\n};\n\nfunction removeAtIndexes(data, index) {\n  var k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return compact(data);\n}\n\nvar removeArrayAt = function removeArrayAt(data, index) {\n  return isUndefined(index) ? [] : Array.isArray(index) ? removeAtIndexes(data, index) : removeAt(data, index);\n};\n\nvar moveArrayAt = function moveArrayAt(data, from, to) {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n\nvar swapArrayAt = function swapArrayAt(data, indexA, indexB) {\n  var temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n\nfunction prepend(data, value) {\n  return [].concat(_toConsumableArray(Array.isArray(value) ? value : [value || undefined]), _toConsumableArray(data));\n}\n\nfunction insert(data, index, value) {\n  return [].concat(_toConsumableArray(data.slice(0, index)), _toConsumableArray(Array.isArray(value) ? value : [value || undefined]), _toConsumableArray(data.slice(index)));\n}\n\nvar fillEmptyArray = function fillEmptyArray(value) {\n  return Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n};\n\nfunction mapValueToBoolean(value) {\n  if (isObject(value)) {\n    var object = {};\n\n    for (var key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nvar fillBooleanArray = function fillBooleanArray(value) {\n  return (Array.isArray(value) ? value : [value]).map(mapValueToBoolean).flat();\n};\n\nvar mapIds = function mapIds() {\n  var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var keyName = arguments.length > 1 ? arguments[1] : undefined;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var _iterator9 = _createForOfIteratorHelper(values),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var value = _step9.value;\n\n        if (keyName in value) {\n          console.warn(\"\\uD83D\\uDCCB useFieldArray fieldValues contain the keyName `\".concat(keyName, \"` which is reserved for use by useFieldArray. https://react-hook-form.com/api#useFieldArray\"));\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n  }\n\n  return values.map(function (value) {\n    return Object.assign(_defineProperty({}, keyName, generateId()), value);\n  });\n};\n\nvar useFieldArray = function useFieldArray(_ref26) {\n  var control = _ref26.control,\n      name = _ref26.name,\n      _ref26$keyName = _ref26.keyName,\n      keyName = _ref26$keyName === void 0 ? 'id' : _ref26$keyName;\n  var methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(' useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray');\n    }\n  }\n\n  var focusIndexRef = useRef(-1);\n\n  var _ref27 = control || methods.control,\n      updateWatchedValue = _ref27.updateWatchedValue,\n      resetFieldArrayFunctionRef = _ref27.resetFieldArrayFunctionRef,\n      fieldArrayNamesRef = _ref27.fieldArrayNamesRef,\n      fieldsRef = _ref27.fieldsRef,\n      defaultValuesRef = _ref27.defaultValuesRef,\n      removeFieldEventListener = _ref27.removeFieldEventListener,\n      formStateRef = _ref27.formStateRef,\n      shallowFieldsStateRef = _ref27.shallowFieldsStateRef,\n      updateFormState = _ref27.updateFormState,\n      readFormStateRef = _ref27.readFormStateRef,\n      validFieldsRef = _ref27.validFieldsRef,\n      fieldsWithValidationRef = _ref27.fieldsWithValidationRef,\n      fieldArrayDefaultValuesRef = _ref27.fieldArrayDefaultValuesRef,\n      validateResolver = _ref27.validateResolver,\n      getValues = _ref27.getValues,\n      shouldUnregister = _ref27.shouldUnregister;\n\n  var fieldArrayParentName = getFieldArrayParentName(name);\n  var memoizedDefaultValues = useRef(_toConsumableArray(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName) ? get(fieldArrayDefaultValuesRef.current, name, []) : get(shouldUnregister ? defaultValuesRef.current : shallowFieldsStateRef.current, name, [])));\n\n  var _useState3 = useState(mapIds(memoizedDefaultValues.current, keyName)),\n      _useState4 = _slicedToArray(_useState3, 2),\n      fields = _useState4[0],\n      setFields = _useState4[1];\n\n  var allFields = useRef(fields);\n\n  var getCurrentFieldsValues = function getCurrentFieldsValues() {\n    return get(getValues(), name, allFields.current).map(function (item, index) {\n      return Object.assign(Object.assign({}, allFields.current[index]), item);\n    });\n  };\n\n  allFields.current = fields;\n  fieldArrayNamesRef.current.add(name);\n\n  if (!get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\n    set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, get(defaultValuesRef.current, fieldArrayParentName));\n  }\n\n  var setFieldAndValidState = function setFieldAndValidState(fieldsValues) {\n    setFields(fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      var values = getValues();\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  var getIsDirtyState = function getIsDirtyState(flagOrFields) {\n    return (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && (isUndefined(flagOrFields) || !deepEqual(flagOrFields.map(function () {\n      var _a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _b = keyName,\n          omitted = _a[_b],\n          rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n      return rest;\n    }), get(defaultValuesRef.current, name)));\n  };\n\n  var resetFields = function resetFields() {\n    for (var key in fieldsRef.current) {\n      isMatchFieldArrayName(key, name) && removeFieldEventListener(fieldsRef.current[key], true);\n    }\n  };\n\n  var cleanup = function cleanup(ref) {\n    return !compact(get(ref, name, [])).length && unset(ref, name);\n  };\n\n  var updateDirtyFieldsWithDefaultValues = function updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues) {\n    var defaultFieldArrayValues = get(defaultValuesRef.current, name, []);\n\n    var updateDirtyFieldsBaseOnDefaultValues = function updateDirtyFieldsBaseOnDefaultValues(base, target) {\n      for (var key in base) {\n        for (var innerKey in base[key]) {\n          if (innerKey !== keyName && (!target[key] || !base[key] || base[key][innerKey] !== target[key][innerKey])) {\n            set(formStateRef.current.dirtyFields, \"\".concat(name, \"[\").concat(key, \"]\"), Object.assign(Object.assign({}, get(formStateRef.current.dirtyFields, \"\".concat(name, \"[\").concat(key, \"]\"), {})), _defineProperty({}, innerKey, true)));\n          }\n        }\n      }\n    };\n\n    if (updatedFieldArrayValues) {\n      updateDirtyFieldsBaseOnDefaultValues(defaultFieldArrayValues, updatedFieldArrayValues);\n      updateDirtyFieldsBaseOnDefaultValues(updatedFieldArrayValues, defaultFieldArrayValues);\n    }\n  };\n\n  var batchStateUpdate = function batchStateUpdate(method, args, updatedFieldValues) {\n    var isDirty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var shouldSet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldUpdateValid = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    if (get(shallowFieldsStateRef.current, name)) {\n      var output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      var _output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\n\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, _output);\n      cleanup(fieldArrayDefaultValuesRef.current);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      var _output2 = method(get(formStateRef.current.errors, name), args.argA, args.argB);\n\n      shouldSet && set(formStateRef.current.errors, name, _output2);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (readFormStateRef.current.touched && get(formStateRef.current.touched, name)) {\n      var _output3 = method(get(formStateRef.current.touched, name), args.argA, args.argB);\n\n      shouldSet && set(formStateRef.current.touched, name, _output3);\n      cleanup(formStateRef.current.touched);\n    }\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      var _output4 = method(get(formStateRef.current.dirtyFields, name, []), args.argC, args.argD);\n\n      shouldSet && set(formStateRef.current.dirtyFields, name, _output4);\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (shouldUpdateValid && readFormStateRef.current.isValid && !validateResolver) {\n      set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\n      cleanup(validFieldsRef.current);\n      set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    updateFormState({\n      errors: formStateRef.current.errors,\n      dirtyFields: formStateRef.current.dirtyFields,\n      isDirty: isDirty,\n      touched: formStateRef.current.touched\n    });\n  };\n\n  var append = function append(value) {\n    var shouldFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var updateFormValues = [].concat(_toConsumableArray(allFields.current), _toConsumableArray(mapIds(Array.isArray(value) ? value : [value], keyName)));\n    setFieldAndValidState(updateFormValues);\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      updateDirtyFieldsWithDefaultValues(updateFormValues);\n      updateFormState({\n        isDirty: true,\n        dirtyFields: formStateRef.current.dirtyFields\n      });\n    }\n\n    !shouldUnregister && set(shallowFieldsStateRef.current, name, [].concat(_toConsumableArray(shallowFieldsStateRef.current[name] || []), [value]));\n    focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\n  };\n\n  var prepend$1 = function prepend$1(value) {\n    var shouldFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var emptyArray = fillEmptyArray(value);\n    var updatedFieldArrayValues = prepend(getCurrentFieldsValues(), mapIds(Array.isArray(value) ? value : [value], keyName));\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(prepend, {\n      argA: emptyArray,\n      argC: fillBooleanArray(value)\n    }, updatedFieldArrayValues);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  var remove = function remove(index) {\n    var fieldValues = getCurrentFieldsValues();\n    var updatedFieldValues = removeArrayAt(fieldValues, index);\n    setFieldAndValidState(updatedFieldValues);\n    resetFields();\n    batchStateUpdate(removeArrayAt, {\n      argA: index,\n      argC: index\n    }, updatedFieldValues, getIsDirtyState(removeArrayAt(fieldValues, index)), true, true);\n  };\n\n  var insert$1 = function insert$1(index, value) {\n    var shouldFocus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var emptyArray = fillEmptyArray(value);\n    var fieldValues = getCurrentFieldsValues();\n    var updatedFieldArrayValues = insert(fieldValues, index, mapIds(Array.isArray(value) ? value : [value], keyName));\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(insert, {\n      argA: index,\n      argB: emptyArray,\n      argC: index,\n      argD: fillBooleanArray(value)\n    }, updatedFieldArrayValues, getIsDirtyState(insert(fieldValues, index)));\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  var swap = function swap(indexA, indexB) {\n    var fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState(_toConsumableArray(fieldValues));\n    batchStateUpdate(swapArrayAt, {\n      argA: indexA,\n      argB: indexB,\n      argC: indexA,\n      argD: indexB\n    }, undefined, getIsDirtyState(fieldValues), false);\n  };\n\n  var move = function move(from, to) {\n    var fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState(_toConsumableArray(fieldValues));\n    batchStateUpdate(moveArrayAt, {\n      argA: from,\n      argB: to,\n      argC: from,\n      argD: to\n    }, undefined, getIsDirtyState(fieldValues), false);\n  };\n\n  var reset = function reset(data) {\n    resetFields();\n    !data && unset(fieldArrayDefaultValuesRef.current, name);\n    unset(shallowFieldsStateRef.current, name);\n    memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\n    setFields(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  useEffect(function () {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!name) {\n        console.warn(' useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray');\n      }\n    }\n\n    var defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      defaultValues.pop();\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues);\n    }\n\n    updateWatchedValue(name);\n\n    if (focusIndexRef.current > -1) {\n      for (var key in fieldsRef.current) {\n        var field = fieldsRef.current[key];\n\n        if (key.startsWith(\"\".concat(name, \"[\").concat(focusIndexRef.current, \"]\")) && field.ref.focus) {\n          field.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n  useEffect(function () {\n    var resetFunctions = resetFieldArrayFunctionRef.current;\n    var fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = reset;\n    }\n\n    return function () {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n  return {\n    swap: useCallback(swap, [name]),\n    move: useCallback(move, [name]),\n    prepend: useCallback(prepend$1, [name]),\n    append: useCallback(append, [name]),\n    remove: useCallback(remove, [name]),\n    insert: useCallback(insert$1, [name]),\n    fields: fields\n  };\n};\n\nfunction useWatch(_ref28) {\n  var control = _ref28.control,\n      name = _ref28.name,\n      defaultValue = _ref28.defaultValue;\n  var methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(' useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch');\n    }\n  }\n\n  var _ref29 = control || methods.control,\n      useWatchFieldsRef = _ref29.useWatchFieldsRef,\n      useWatchRenderFunctionsRef = _ref29.useWatchRenderFunctionsRef,\n      watchInternal = _ref29.watchInternal,\n      defaultValuesRef = _ref29.defaultValuesRef;\n\n  var _useState5 = useState(isUndefined(defaultValue) ? isString(name) ? get(defaultValuesRef.current, name) : Array.isArray(name) ? name.reduce(function (previous, inputName) {\n    return Object.assign(Object.assign({}, previous), _defineProperty({}, inputName, get(defaultValuesRef.current, inputName)));\n  }, {}) : defaultValuesRef.current : defaultValue),\n      _useState6 = _slicedToArray(_useState5, 2),\n      value = _useState6[0],\n      setValue = _useState6[1];\n\n  var idRef = useRef();\n  var defaultValueRef = useRef(defaultValue);\n  var updateWatchValue = useCallback(function () {\n    var value = watchInternal(name, defaultValueRef.current, idRef.current);\n    setValue(isObject(value) ? Object.assign({}, value) : Array.isArray(value) ? _toConsumableArray(value) : value);\n  }, [setValue, watchInternal, defaultValueRef, name, idRef]);\n  useEffect(function () {\n    if (process.env.NODE_ENV !== 'production') {\n      if (name === '') {\n        console.warn(' useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch');\n      }\n    }\n\n    var id = idRef.current = generateId();\n    var watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    var watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(name, defaultValueRef.current, id);\n    return function () {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [name, updateWatchValue, useWatchRenderFunctionsRef, useWatchFieldsRef, watchInternal, defaultValueRef]);\n  return isUndefined(value) ? defaultValue : value;\n}\n\nvar getInputValue = function getInputValue(event) {\n  return isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isUndefined(event.target.value) ? event.target.checked : event.target.value;\n};\n\nvar Controller = function Controller(_a) {\n  var name = _a.name,\n      rules = _a.rules,\n      as = _a.as,\n      render = _a.render,\n      defaultValue = _a.defaultValue,\n      control = _a.control,\n      onFocus = _a.onFocus,\n      rest = __rest(_a, [\"name\", \"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\n\n  var methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(' Controller is missing `control` prop. https://react-hook-form.com/api#Controller');\n    }\n  }\n\n  var _ref30 = control || methods.control,\n      defaultValuesRef = _ref30.defaultValuesRef,\n      setValue = _ref30.setValue,\n      register = _ref30.register,\n      unregister = _ref30.unregister,\n      trigger = _ref30.trigger,\n      mode = _ref30.mode,\n      _ref30$reValidateMode = _ref30.reValidateMode,\n      isReValidateOnBlur = _ref30$reValidateMode.isReValidateOnBlur,\n      isReValidateOnChange = _ref30$reValidateMode.isReValidateOnChange,\n      _ref30$formStateRef$c = _ref30.formStateRef.current,\n      isSubmitted = _ref30$formStateRef$c.isSubmitted,\n      touched = _ref30$formStateRef$c.touched,\n      updateFormState = _ref30.updateFormState,\n      readFormStateRef = _ref30.readFormStateRef,\n      fieldsRef = _ref30.fieldsRef,\n      fieldArrayNamesRef = _ref30.fieldArrayNamesRef,\n      shallowFieldsStateRef = _ref30.shallowFieldsStateRef;\n\n  var isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n  var getInitialValue = function getInitialValue() {\n    return !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray ? get(shallowFieldsStateRef.current, name) : isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue;\n  };\n\n  var _useState7 = useState(getInitialValue()),\n      _useState8 = _slicedToArray(_useState7, 2),\n      value = _useState8[0],\n      setInputStateValue = _useState8[1];\n\n  var valueRef = useRef(value);\n  var ref = useRef({\n    focus: function focus() {\n      return null;\n    }\n  });\n  var onFocusRef = useRef(onFocus || function () {\n    return ref.current.focus();\n  });\n\n  var shouldValidate = function shouldValidate(isBlurEvent) {\n    return !skipValidation(Object.assign({\n      isBlurEvent: isBlurEvent,\n      isReValidateOnBlur: isReValidateOnBlur,\n      isReValidateOnChange: isReValidateOnChange,\n      isSubmitted: isSubmitted,\n      isTouched: !!get(touched, name)\n    }, mode));\n  };\n\n  var commonTask = function commonTask(_ref31) {\n    var _ref32 = _slicedToArray(_ref31, 1),\n        event = _ref32[0];\n\n    var data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  var registerField = useCallback(function () {\n    if (process.env.NODE_ENV !== 'production' && !name) {\n      return console.warn(' Field is missing `name` prop. https://react-hook-form.com/api#Controller');\n    }\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = Object.assign({\n        ref: fieldsRef.current[name].ref\n      }, rules);\n    } else {\n      register(Object.defineProperty({\n        name: name,\n        focus: onFocusRef.current\n      }, VALUE, {\n        set: function set(data) {\n          setInputStateValue(data);\n          valueRef.current = data;\n        },\n        get: function get() {\n          return valueRef.current;\n        }\n      }), rules);\n\n      if (isNotFieldArray && !get(defaultValuesRef.current, name)) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  }, [rules, name, register]);\n  useEffect(function () {\n    return function () {\n      return unregister(name);\n    };\n  }, [unregister, name]);\n  useEffect(function () {\n    if (process.env.NODE_ENV !== 'production') {\n      if (isUndefined(value)) {\n        console.warn(\"\\uD83D\\uDCCB \".concat(name, \" is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)\"));\n      }\n\n      if (!as && !render || as && render) {\n        console.warn(\"\\uD83D\\uDCCB \".concat(name, \" Controller should use either the 'as' or 'render' prop, not both. https://react-hook-form.com/api#Controller\"));\n      }\n\n      if (!isNotFieldArray && isUndefined(defaultValue)) {\n        console.warn(' Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller');\n      }\n    }\n\n    registerField();\n  }, [registerField]);\n  useEffect(function () {\n    if (!fieldsRef.current[name]) {\n      registerField();\n\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n\n  var onBlur = function onBlur() {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched: touched\n      });\n    }\n\n    if (shouldValidate(true)) {\n      trigger(name);\n    }\n  };\n\n  var onChange = function onChange() {\n    for (var _len = arguments.length, event = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n      event[_key2] = arguments[_key2];\n    }\n\n    return setValue(name, commonTask(event), {\n      shouldValidate: shouldValidate(),\n      shouldDirty: true\n    });\n  };\n\n  var commonProps = {\n    onChange: onChange,\n    onBlur: onBlur,\n    name: name,\n    value: value,\n    ref: ref\n  };\n  var props = Object.assign(Object.assign({}, rest), commonProps);\n  return as ? isValidElement(as) ? cloneElement(as, props) : createElement(as, props) : render ? render(commonProps) : null;\n};\n\nexport { Controller, FormProvider, appendErrors, get, transformToNestObject, useFieldArray, useForm, useFormContext, useWatch };","map":{"version":3,"sources":["../src/utils/isHTMLElement.ts","../src/constants.ts","../src/logic/attachEventListeners.ts","../src/utils/isNullOrUndefined.ts","../src/utils/isObject.ts","../src/utils/isKey.ts","../src/utils/compact.ts","../src/utils/stringToPath.ts","../src/utils/set.ts","../src/logic/transformToNestObject.ts","../src/utils/isUndefined.ts","../src/utils/get.ts","../src/logic/focusOnErrorField.ts","../src/logic/removeAllEventListeners.ts","../src/logic/getRadioValue.ts","../src/logic/getMultipleSelectValue.ts","../src/utils/isRadioInput.ts","../src/utils/isFileInput.ts","../src/utils/isCheckBoxInput.ts","../src/utils/isMultipleSelect.ts","../src/logic/getCheckboxValue.ts","../src/logic/getFieldValue.ts","../src/utils/isDetached.ts","../src/utils/isEmptyObject.ts","../src/utils/isBoolean.ts","../src/utils/unset.ts","../src/logic/findRemovedFieldAndRemoveListener.ts","../src/logic/setFieldArrayDirtyFields.ts","../src/utils/isString.ts","../src/utils/isPrimitive.ts","../src/utils/deepMerge.ts","../src/logic/getFieldsValues.ts","../src/utils/deepEqual.ts","../src/logic/isErrorStateChanged.ts","../src/utils/isRegex.ts","../src/logic/getValueAndMessage.ts","../src/utils/isFunction.ts","../src/utils/isMessage.ts","../src/logic/getValidateError.ts","../src/logic/appendErrors.ts","../src/logic/validateField.ts","../src/utils/getPath.ts","../src/logic/assignWatchFields.ts","../src/logic/skipValidation.ts","../src/logic/getFieldArrayParentName.ts","../src/logic/isNameInFieldArray.ts","../src/utils/isSelectInput.ts","../src/utils/onDomRemove.ts","../src/utils/cloneObject.ts","../src/utils/validationModeChecker.ts","../src/utils/isRadioOrCheckbox.ts","../src/useForm.ts","../src/useFormContext.tsx","../src/logic/generateId.ts","../src/utils/remove.ts","../src/utils/move.ts","../src/utils/swap.ts","../src/utils/prepend.ts","../src/utils/insert.ts","../src/utils/fillEmptyArray.ts","../src/utils/fillBooleanArray.ts","../src/useFieldArray.ts","../src/useWatch.ts","../src/logic/getInputValue.ts","../src/controller.tsx"],"names":["isCheckBox","getFieldsValue","React.useRef","React.useState","React.useCallback","React.useEffect","React.createContext","React.useContext","React.createElement","prepend","prependAt","insert","insertAt","React.isValidElement","React.cloneElement"],"mappings":"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","sourcesContent":["export default (value: any): value is HTMLElement =>\n  value instanceof HTMLElement;\n","import { ValidationMode } from './types';\n\nexport const EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input',\n};\n\nexport const VALIDATION_MODE: ValidationMode = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all',\n};\n\nexport const VALUE = 'value';\n\nexport const SELECT = 'select';\n\nexport const UNDEFINED = 'undefined';\n\nexport const INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate',\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Field } from '../types';\n\nexport default function attachEventListeners(\n  { ref }: Field,\n  shouldAttachChangeEvent?: boolean,\n  handleChange?: EventListenerOrEventListenerObject,\n): void {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(\n      shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT,\n      handleChange,\n    );\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n","export default (value: unknown): value is null | undefined => value == null;\n","import isNullOrUndefined from './isNullOrUndefined';\n\nexport const isObjectType = (value: unknown) => typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) &&\n  !Array.isArray(value) &&\n  isObjectType(value) &&\n  !(value instanceof Date);\n","export default (value: [] | string) =>\n  !Array.isArray(value) &&\n  (/^\\w*$/.test(value) ||\n    !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n","export default (value: any[]) => value.filter(Boolean);\n","import compact from './compact';\n\nexport default (input: string): string[] =>\n  compact(\n    input\n      .replace(/[\"|']/g, '')\n      .replace(/\\[/g, '.')\n      .replace(/\\]/g, '')\n      .split('.'),\n  );\n","import isObject from './isObject';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport { FieldValues } from '../types';\n\nexport default function set(\n  object: FieldValues,\n  path: string,\n  value?: unknown,\n) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue =\n        isObject(objValue) || Array.isArray(objValue)\n          ? objValue\n          : !isNaN(+tempPath[index + 1])\n          ? []\n          : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\n","import set from '../utils/set';\nimport isKey from '../utils/isKey';\nimport { FieldValues } from '../types';\n\nexport default (data: FieldValues, value: Record<string, any> = {}): any => {\n  for (const key in data) {\n    !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\n  }\n  return value;\n};\n","export default (val: unknown): val is undefined => val === undefined;\n","import isUndefined from './isUndefined';\nimport isNullOrUndefined from './isNullOrUndefined';\nimport compact from './compact';\n\nexport default (obj: any, path: string, defaultValue?: unknown) => {\n  const result = compact(path.split(/[,[\\].]+?/)).reduce(\n    (result, key) => (isNullOrUndefined(result) ? result : result[key]),\n    obj,\n  );\n\n  return isUndefined(result) || result === obj\n    ? isUndefined(obj[path])\n      ? defaultValue\n      : obj[path]\n    : result;\n};\n","import get from '../utils/get';\nimport { FieldErrors, FieldRefs } from '../types';\nimport isUndefined from '../utils/isUndefined';\n\nexport default <TFieldValues>(\n  fields: FieldRefs<TFieldValues>,\n  fieldErrors: FieldErrors<TFieldValues>,\n) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          if (isUndefined(field.ref.focus())) {\n            break;\n          }\n        } else if (field.options) {\n          field.options[0].ref.focus();\n\n          break;\n        }\n      }\n    }\n  }\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Ref } from '../types';\n\nexport default (\n  ref: Ref,\n  validateWithStateUpdate: EventListenerOrEventListenerObject,\n): void => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n","import { RadioOrCheckboxOption } from '../types';\n\ntype RadioFieldResult = {\n  isValid: boolean;\n  value: number | string;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: '',\n};\n\nexport default (options?: RadioOrCheckboxOption[]): RadioFieldResult =>\n  Array.isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.ref.checked\n            ? {\n                isValid: true,\n                value: option.ref.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n","export default (\n  options: HTMLOptionElement[] | HTMLOptionsCollection,\n): string[] =>\n  [...options]\n    .filter(({ selected }): boolean => selected)\n    .map(({ value }): string => value);\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'radio';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-multiple`;\n","import isUndefined from '../utils/isUndefined';\nimport { RadioOrCheckboxOption } from '../types';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: RadioOrCheckboxOption[]): CheckboxFieldResult => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.ref.checked)\n        .map(({ ref: { value } }) => value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    const { checked, value, attributes } = options[0].ref;\n\n    return checked\n      ? attributes && !isUndefined((attributes as any).value)\n        ? isUndefined(value) || value === ''\n          ? validResult\n          : { value: value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getMultipleSelectValue from './getMultipleSelectValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport get from '../utils/get';\nimport isFileInput from '../utils/isFileInput';\nimport isCheckBox from '../utils/isCheckBoxInput';\nimport isMultipleSelect from '../utils/isMultipleSelect';\nimport getCheckboxValue from './getCheckboxValue';\nimport { FieldRefs, FieldValues, InternalFieldName } from '../types';\n\nexport default function getFieldValue<TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  name: InternalFieldName<TFieldValues>,\n  shallowFieldsStateRef?: React.MutableRefObject<Partial<FieldValues>>,\n  excludeDisabled?: boolean,\n) {\n  const field = fieldsRef.current[name]!;\n\n  if (field) {\n    const {\n      ref: { value, disabled },\n      ref,\n    } = field;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBox(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n","import { Ref } from '../types';\n\nexport default function isDetached(element: Ref): boolean {\n  if (!element) {\n    return true;\n  }\n\n  if (\n    !(element instanceof HTMLElement) ||\n    element.nodeType === Node.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n\n  return isDetached(element.parentNode as Ref);\n}\n","import isObject from './isObject';\nimport { EmptyObject } from '../types';\n\nexport default (value: unknown): value is EmptyObject =>\n  isObject(value) && !Object.keys(value).length;\n","export default (value: unknown): value is boolean => typeof value === 'boolean';\n","import isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport isEmptyObject from './isEmptyObject';\nimport isObject from './isObject';\nimport isUndefined from './isUndefined';\nimport isBoolean from './isBoolean';\n\nfunction baseGet(object: any, updatePath: (string | number)[]) {\n  const path = updatePath.slice(0, -1);\n  const length = path.length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nexport default function unset(object: any, path: string) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject =\n    updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (\n        currentPathsLength === index &&\n        ((isObject(objectRef) && isEmptyObject(objectRef)) ||\n          (Array.isArray(objectRef) &&\n            !objectRef.filter(\n              (data) =>\n                (isObject(data) && !isEmptyObject(data)) || isBoolean(data),\n            ).length))\n      ) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n","import * as React from 'react';\nimport removeAllEventListeners from './removeAllEventListeners';\nimport getFieldValue from './getFieldValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport set from '../utils/set';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isDetached from '../utils/isDetached';\nimport unset from '../utils/unset';\nimport compact from '../utils/compact';\nimport isUndefined from '../utils/isUndefined';\nimport { Field, FieldRefs, FieldValues, Ref } from '../types';\n\nconst isSameRef = (fieldValue: Field, ref: Ref) =>\n  fieldValue && fieldValue.ref === ref;\n\nexport default function findRemovedFieldAndRemoveListener<\n  TFieldValues extends FieldValues\n>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  handleChange: ({ type, target }: Event) => Promise<void | boolean>,\n  field: Field,\n  shallowFieldsStateRef: React.MutableRefObject<FieldValues>,\n  shouldUnregister?: boolean,\n  forceDelete?: boolean,\n): void {\n  const {\n    ref,\n    ref: { name, type },\n  } = field;\n  const fieldRef = fieldsRef.current[name] as Field;\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n\n    if (!isUndefined(value)) {\n      set(shallowFieldsStateRef.current, name, value);\n    }\n  }\n\n  if (!type) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    const { options } = fieldRef;\n\n    if (Array.isArray(options) && options.length) {\n      compact(options).forEach((option, index): void => {\n        const { ref } = option;\n        if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n          unset(options, `[${index}]`);\n        }\n      });\n\n      if (options && !compact(options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    delete fieldsRef.current[name];\n  }\n}\n","import { get } from '../utils';\nimport set from '../utils/set';\n\nexport default function setFieldArrayDirtyFields<\n  T extends U,\n  U extends Record<string, unknown>[],\n  K extends Record<string, boolean | []>\n>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n  parentNode?: K,\n  parentName?: keyof K,\n) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setFieldArrayDirtyFields(\n          values[index][key],\n          get(defaultValues[index] || {}, key, []),\n          dirtyFields[index][key] as [],\n          dirtyFields[index],\n          key,\n        );\n      } else {\n        get(defaultValues[index] || {}, key) === values[index][key]\n          ? set(dirtyFields[index] || {}, key)\n          : (dirtyFields[index] = {\n              ...dirtyFields[index],\n              [key]: true,\n            });\n      }\n    }\n    !dirtyFields.length &&\n      parentNode &&\n      delete parentNode[parentName as keyof K];\n  }\n\n  return dirtyFields.length ? dirtyFields : undefined;\n}\n","export default (value: unknown): value is string => typeof value === 'string';\n","import isNullOrUndefined from './isNullOrUndefined';\nimport { isObjectType } from './isObject';\nimport { Primitive } from '../types';\n\nexport default (value: unknown): value is Primitive =>\n  isNullOrUndefined(value) || !isObjectType(value);\n","import isObject from './isObject';\nimport isPrimitive from './isPrimitive';\n\nexport function deepMerge<\n  T extends Record<keyof T, any>,\n  U extends Record<keyof U, any>\n>(target: T, source: U): T & U {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] =\n        (isObject(targetValue) && isObject(sourceValue)) ||\n        (Array.isArray(targetValue) && Array.isArray(sourceValue))\n          ? deepMerge(targetValue, sourceValue)\n          : sourceValue;\n    } catch {}\n  }\n\n  return target;\n}\n","import * as React from 'react';\nimport getFieldValue from './getFieldValue';\nimport isString from '../utils/isString';\nimport { deepMerge } from '../utils/deepMerge';\nimport isUndefined from '../utils/isUndefined';\nimport { InternalFieldName, FieldValues, FieldRefs } from '../types';\nimport transformToNestObject from './transformToNestObject';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  shallowFieldsStateRef?: React.MutableRefObject<Record<string, any>>,\n  excludeDisabled?: boolean,\n  search?:\n    | InternalFieldName<TFieldValues>\n    | InternalFieldName<TFieldValues>[]\n    | { nest: boolean },\n) => {\n  const output = {} as TFieldValues;\n\n  for (const name in fieldsRef.current) {\n    if (\n      isUndefined(search) ||\n      (isString(search)\n        ? name.startsWith(search)\n        : Array.isArray(search) && search.find((data) => name.startsWith(data)))\n    ) {\n      output[name as InternalFieldName<TFieldValues>] = getFieldValue(\n        fieldsRef,\n        name,\n        undefined,\n        excludeDisabled,\n      );\n    }\n  }\n\n  return deepMerge(\n    transformToNestObject({ ...((shallowFieldsStateRef || {}).current || {}) }),\n    transformToNestObject(output),\n  );\n};\n","import isObject from '../utils/isObject';\nimport isPrimitive from './isPrimitive';\n\nexport default function deepEqual(\n  object1: any = [],\n  object2: any = [],\n  isErrorObject?: boolean,\n) {\n  if (isPrimitive(object1) && isPrimitive(object2)) {\n    return object1 === object2;\n  }\n\n  const keys1 = Object.keys(object1);\n  const keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (const key of keys1) {\n    if (!(isErrorObject && ['ref', 'context'].includes(key))) {\n      const val1 = object1[key];\n      const val2 = object2[key];\n\n      if (\n        (isObject(val1) || Array.isArray(val1)) &&\n        (isObject(val2) || Array.isArray(val2))\n          ? !deepEqual(val1, val2, isErrorObject)\n          : val1 !== val2\n      ) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n","import get from '../utils/get';\nimport isUndefined from '../utils/isUndefined';\nimport deepEqual from '../utils/deepEqual';\nimport {\n  FieldValues,\n  InternalFieldName,\n  FieldErrors,\n  FieldNamesMarkedBoolean,\n  FieldError,\n} from '../types';\n\nexport default function isErrorStateChanged<TFieldValues extends FieldValues>({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation,\n}: {\n  errors: FieldErrors<TFieldValues>;\n  error: FieldError | undefined;\n  name: InternalFieldName<TFieldValues>;\n  validFields: FieldNamesMarkedBoolean<TFieldValues>;\n  fieldsWithValidation: FieldNamesMarkedBoolean<TFieldValues>;\n}): boolean {\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n\n  return (\n    (isValid && !!previousError) ||\n    (!isValid && !deepEqual(previousError, error, true)) ||\n    (isValid && get(fieldsWithValidation, name) && !get(validFields, name))\n  );\n}\n","export default (value: unknown): value is RegExp => value instanceof RegExp;\n","import isObject from '../utils/isObject';\nimport isRegex from '../utils/isRegex';\nimport { ValidationRule, ValidationValueMessage } from '../types';\n\nconst isValueMessage = (\n  value?: ValidationRule,\n): value is ValidationValueMessage => isObject(value) && !isRegex(value);\n\nexport default (validationData?: ValidationRule) =>\n  isValueMessage(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n      };\n","export default (value: unknown): value is Function =>\n  typeof value === 'function';\n","import { isValidElement } from 'react';\nimport isString from '../utils/isString';\nimport isObject from '../utils/isObject';\nimport { Message } from '../types';\n\nexport default (value: unknown): value is Message =>\n  isString(value) || (isObject(value) && isValidElement(value));\n","import isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport { FieldError, ValidateResult, Ref } from '../types';\n\nexport default function getValidateError(\n  result: ValidateResult,\n  ref: Ref,\n  type = 'validate',\n): FieldError | void {\n  if (isMessage(result) || (isBoolean(result) && !result)) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref,\n    };\n  }\n}\n","import {\n  InternalFieldName,\n  ValidateResult,\n  InternalFieldErrors,\n} from '../types';\n\nexport default <TFieldValues>(\n  name: InternalFieldName<TFieldValues>,\n  validateAllFieldCriteria: boolean,\n  errors: InternalFieldErrors<TFieldValues>,\n  type: string,\n  message: ValidateResult,\n) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n\n    return {\n      ...error,\n      types: {\n        ...(error && error.types ? error.types : {}),\n        [type]: message || true,\n      },\n    };\n  }\n\n  return {};\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getCheckboxValue from './getCheckboxValue';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isRadioInput from '../utils/isRadioInput';\nimport getValueAndMessage from './getValueAndMessage';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isString from '../utils/isString';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isObject from '../utils/isObject';\nimport isFunction from '../utils/isFunction';\nimport getFieldsValue from './getFieldValue';\nimport isRegex from '../utils/isRegex';\nimport isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport getValidateError from './getValidateError';\nimport appendErrors from './appendErrors';\nimport { INPUT_VALIDATION_RULES } from '../constants';\nimport {\n  Field,\n  FieldValues,\n  FieldRefs,\n  Message,\n  FieldError,\n  InternalFieldName,\n  InternalFieldErrors,\n} from '../types';\n\nexport default async <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  validateAllFieldCriteria: boolean,\n  {\n    ref,\n    ref: { type, value },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate,\n  }: Field,\n  shallowFieldsStateRef: React.MutableRefObject<Record<string, any>>,\n): Promise<InternalFieldErrors<TFieldValues>> => {\n  const fields = fieldsRef.current;\n  const name: InternalFieldName<TFieldValues> = ref.name;\n  const error: InternalFieldErrors<TFieldValues> = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = value === '';\n  const appendErrorsCurry = appendErrors.bind(\n    null,\n    name,\n    validateAllFieldCriteria,\n    error,\n  );\n  const getMinMaxMessage = (\n    exceedMax: boolean,\n    maxLengthMessage: Message,\n    minLengthMessage: Message,\n    maxType = INPUT_VALIDATION_RULES.maxLength,\n    minType = INPUT_VALIDATION_RULES.minLength,\n  ) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = {\n      type: exceedMax ? maxType : minType,\n      message,\n      ref,\n      ...(exceedMax\n        ? appendErrorsCurry(maxType, message)\n        : appendErrorsCurry(minType, message)),\n    };\n  };\n\n  if (\n    required &&\n    ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\n      (isBoolean(value) && !value) ||\n      (isCheckBox && !getCheckboxValue(options).isValid) ||\n      (isRadio && !getRadioValue(options).isValid))\n  ) {\n    const { value: requiredValue, message: requiredMessage } = isMessage(\n      required,\n    )\n      ? { value: !!required, message: required }\n      : getValueAndMessage(required);\n\n    if (requiredValue) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.required,\n        message: requiredMessage,\n        ref: isRadioOrCheckbox\n          ? (((fields[name] as Field).options || [])[0] || {}).ref\n          : ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n    const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\n    const { value: minValue, message: minMessage } = getValueAndMessage(min);\n\n    if (type === 'number' || (!type && !isNaN(value))) {\n      const valueNumber =\n        (ref as HTMLInputElement).valueAsNumber || parseFloat(value);\n      if (!isNullOrUndefined(maxValue)) {\n        exceedMax = valueNumber > maxValue;\n      }\n      if (!isNullOrUndefined(minValue)) {\n        exceedMin = valueNumber < minValue;\n      }\n    } else {\n      const valueDate =\n        (ref as HTMLInputElement).valueAsDate || new Date(value);\n      if (isString(maxValue)) {\n        exceedMax = valueDate > new Date(maxValue);\n      }\n      if (isString(minValue)) {\n        exceedMin = valueDate < new Date(minValue);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        !!exceedMax,\n        maxMessage,\n        minMessage,\n        INPUT_VALIDATION_RULES.max,\n        INPUT_VALIDATION_RULES.min,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const {\n      value: maxLengthValue,\n      message: maxLengthMessage,\n    } = getValueAndMessage(maxLength);\n    const {\n      value: minLengthValue,\n      message: minLengthMessage,\n    } = getValueAndMessage(minLength);\n    const inputLength = value.toString().length;\n    const exceedMax =\n      !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n    const exceedMin =\n      !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (pattern && !isEmpty) {\n    const { value: patternValue, message: patternMessage } = getValueAndMessage(\n      pattern,\n    );\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.pattern,\n        message: patternMessage,\n        ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldsValue(fieldsRef, name, shallowFieldsStateRef);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = {\n          ...validateError,\n          ...appendErrorsCurry(\n            INPUT_VALIDATION_RULES.validate,\n            validateError.message,\n          ),\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {} as FieldError;\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(\n          validateResult,\n          validateRef,\n          key,\n        );\n\n        if (validateError) {\n          validationResult = {\n            ...validateError,\n            ...appendErrorsCurry(key, validateError.message),\n          };\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = {\n          ref: validateRef,\n          ...validationResult,\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n","import isPrimitive from './isPrimitive';\nimport isObject from './isObject';\n\nexport const getPath = <T extends string, U extends object | unknown[]>(\n  path: T,\n  values: U,\n): string[] => {\n  const getInnerPath = <K>(key: K, value: U, isObject?: boolean) => {\n    const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return Object.entries(values)\n    .map(([key, value]) => getInnerPath(key, value, isObject(values)))\n    .flat(Infinity) as string[];\n};\n","import get from '../utils/get';\nimport { getPath } from '../utils/getPath';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport {\n  DeepPartial,\n  FieldValue,\n  FieldValues,\n  InternalFieldName,\n  UnpackNestedValue,\n} from '../types';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldValues: TFieldValues,\n  fieldName: InternalFieldName<TFieldValues>,\n  watchFields: Set<InternalFieldName<TFieldValues>>,\n  inputValue: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  isSingleField?: boolean,\n):\n  | FieldValue<TFieldValues>\n  | UnpackNestedValue<DeepPartial<TFieldValues>>\n  | undefined => {\n  let value;\n\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || Array.isArray(value)) {\n      getPath(fieldName, value).forEach((name) => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value)\n    ? isSingleField\n      ? inputValue\n      : get(inputValue, fieldName)\n    : value;\n};\n","export default ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll,\n}: {\n  isOnAll?: boolean;\n  isOnBlur?: boolean;\n  isOnChange?: boolean;\n  isReValidateOnBlur?: boolean;\n  isReValidateOnChange?: boolean;\n  isBlurEvent?: boolean;\n  isSubmitted?: boolean;\n  isOnTouch?: boolean;\n  isTouched?: boolean;\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n  return true;\n};\n","export default (name: string) => name.substring(0, name.indexOf('['));\n","import { FieldValues, InternalFieldName } from '../types';\n\nexport const isMatchFieldArrayName = (name: string, searchName: string) =>\n  RegExp(\n    `^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]'),\n  ).test(name);\n\nexport default (\n  names: Set<InternalFieldName<FieldValues>>,\n  name: InternalFieldName<FieldValues>,\n) => [...names].some((current) => isMatchFieldArrayName(name, current));\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-one`;\n","import * as React from 'react';\nimport { Field, FieldRefs } from '../types';\nimport isDetached from './isDetached';\n\nexport default function onDomRemove<TFieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  removeFieldEventListenerAndRef: (\n    field: Field | undefined,\n    forceDelete?: boolean,\n  ) => void,\n): MutationObserver {\n  const observer = new MutationObserver((): void => {\n    for (const field of Object.values(fieldsRef.current)) {\n      if (field && field.options) {\n        for (const option of field.options) {\n          if (option && option.ref && isDetached(option.ref)) {\n            removeFieldEventListenerAndRef(field);\n          }\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true,\n  });\n\n  return observer;\n}\n","import isPrimitive from './isPrimitive';\n\nexport default function cloneObject<T extends unknown>(\n  data: T,\n  isWeb: boolean,\n): T {\n  let copy: any;\n\n  if (isPrimitive(data) || (isWeb && data instanceof File)) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n    for (const item of data) {\n      copy.add(item);\n    }\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n    for (const key of data.keys()) {\n      copy.set(key, cloneObject(data.get(key), isWeb));\n    }\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (const key in data) {\n    copy[key] = cloneObject(data[key], isWeb);\n  }\n\n  return copy;\n}\n","import { VALIDATION_MODE } from '../constants';\nimport { Mode } from '../types';\n\nexport default (\n  mode?: Mode,\n): {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n  isOnTouch: boolean;\n} => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched,\n});\n","import isRadioInput from './isRadioInput';\nimport isCheckBoxInput from './isCheckBoxInput';\nimport { FieldElement } from '../types';\n\nexport default (ref: FieldElement): ref is HTMLInputElement =>\n  isRadioInput(ref) || isCheckBoxInput(ref);\n","import * as React from 'react';\nimport attachEventListeners from './logic/attachEventListeners';\nimport transformToNestObject from './logic/transformToNestObject';\nimport focusOnErrorField from './logic/focusOnErrorField';\nimport findRemovedFieldAndRemoveListener from './logic/findRemovedFieldAndRemoveListener';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldValue from './logic/getFieldValue';\nimport isErrorStateChanged from './logic/isErrorStateChanged';\nimport validateField from './logic/validateField';\nimport assignWatchFields from './logic/assignWatchFields';\nimport skipValidation from './logic/skipValidation';\nimport getFieldArrayParentName from './logic/getFieldArrayParentName';\nimport deepEqual from './utils/deepEqual';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport isCheckBoxInput from './utils/isCheckBoxInput';\nimport isEmptyObject from './utils/isEmptyObject';\nimport isRadioInput from './utils/isRadioInput';\nimport isSelectInput from './utils/isSelectInput';\nimport isFileInput from './utils/isFileInput';\nimport onDomRemove from './utils/onDomRemove';\nimport isObject from './utils/isObject';\nimport { getPath } from './utils/getPath';\nimport isPrimitive from './utils/isPrimitive';\nimport isFunction from './utils/isFunction';\nimport isString from './utils/isString';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport unset from './utils/unset';\nimport isKey from './utils/isKey';\nimport cloneObject from './utils/cloneObject';\nimport modeChecker from './utils/validationModeChecker';\nimport isMultipleSelect from './utils/isMultipleSelect';\nimport compact from './utils/compact';\nimport isNullOrUndefined from './utils/isNullOrUndefined';\nimport isRadioOrCheckboxFunction from './utils/isRadioOrCheckbox';\nimport isHTMLElement from './utils/isHTMLElement';\nimport { EVENTS, UNDEFINED, VALIDATION_MODE } from './constants';\nimport {\n  UseFormMethods,\n  FieldValues,\n  UnpackNestedValue,\n  FieldName,\n  InternalFieldName,\n  FieldValue,\n  FieldErrors,\n  Field,\n  FieldRefs,\n  UseFormOptions,\n  ValidationRules,\n  SubmitHandler,\n  FieldElement,\n  FormStateProxy,\n  ReadFormState,\n  Ref,\n  HandleChange,\n  RadioOrCheckboxOption,\n  OmitResetState,\n  NestedValue,\n  SetValueConfig,\n  ErrorOption,\n  FormState,\n  SubmitErrorHandler,\n  FieldNamesMarkedBoolean,\n  LiteralToPrimitive,\n  DeepPartial,\n  InternalNameSet,\n  DefaultValues,\n  FieldError,\n} from './types';\n\nconst isWindowUndefined = typeof window === UNDEFINED;\nconst isWeb =\n  typeof document !== UNDEFINED &&\n  !isWindowUndefined &&\n  !isUndefined(window.HTMLElement);\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nexport function useForm<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext extends object = object\n>({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {} as UnpackNestedValue<DeepPartial<TFieldValues>>,\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode,\n}: UseFormOptions<TFieldValues, TContext> = {}): UseFormMethods<TFieldValues> {\n  const fieldsRef = React.useRef<FieldRefs<TFieldValues>>({});\n  const fieldArrayDefaultValuesRef = React.useRef<\n    Record<InternalFieldName<FieldValues>, unknown[]>\n  >({});\n  const watchFieldsRef = React.useRef<InternalNameSet<TFieldValues>>(new Set());\n  const useWatchFieldsRef = React.useRef<\n    Record<string, InternalNameSet<TFieldValues>>\n  >({});\n  const useWatchRenderFunctionsRef = React.useRef<Record<string, () => void>>(\n    {},\n  );\n  const fieldsWithValidationRef = React.useRef<\n    FieldNamesMarkedBoolean<TFieldValues>\n  >({});\n  const validFieldsRef = React.useRef<FieldNamesMarkedBoolean<TFieldValues>>(\n    {},\n  );\n  const defaultValuesRef = React.useRef<DefaultValues<TFieldValues>>(\n    defaultValues,\n  );\n  const defaultValuesAtRenderRef = React.useRef<\n    Partial<DefaultValues<TFieldValues>>\n  >({});\n  const isUnMount = React.useRef(false);\n  const isWatchAllRef = React.useRef(false);\n  const handleChangeRef = React.useRef<HandleChange>();\n  const shallowFieldsStateRef = React.useRef(\n    shouldUnregister ? {} : cloneObject(defaultValues, isWeb),\n  );\n  const resetFieldArrayFunctionRef = React.useRef<\n    Record<\n      InternalFieldName<FieldValues>,\n      (data?: UnpackNestedValue<DeepPartial<TFieldValues>>) => void\n    >\n  >({});\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef<InternalNameSet<TFieldValues>>(\n    new Set(),\n  );\n  const modeRef = React.useRef(modeChecker(mode));\n  const { isOnSubmit, isOnTouch } = modeRef.current;\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = React.useState<FormState<TFieldValues>>({\n    isDirty: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {},\n  });\n  const readFormStateRef = React.useRef<ReadFormState>({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n  });\n  const formStateRef = React.useRef(formState);\n  const observerRef = React.useRef<MutationObserver | undefined>();\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnChange: isReValidateOnChange,\n  } = React.useRef(modeChecker(reValidateMode)).current;\n\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n\n  const updateFormState = React.useCallback(\n    (state: Partial<FormState<TFieldValues>> = {}) =>\n      !isUnMount.current &&\n      setFormState({\n        ...formStateRef.current,\n        ...state,\n      }),\n    [],\n  );\n\n  const shouldRenderBaseOnError = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      error: FieldError | undefined,\n      shouldRender: boolean | null = false,\n      state: {\n        dirtyFields?: FieldNamesMarkedBoolean<TFieldValues>;\n        isDirty?: boolean;\n        touched?: FieldNamesMarkedBoolean<TFieldValues>;\n      } = {},\n      isValid?: boolean,\n    ): boolean | void => {\n      let shouldReRender =\n        shouldRender ||\n        isErrorStateChanged<TFieldValues>({\n          errors: formStateRef.current.errors,\n          error,\n          name,\n          validFields: validFieldsRef.current,\n          fieldsWithValidation: fieldsWithValidationRef.current,\n        });\n      const previousError = get(formStateRef.current.errors, name);\n\n      if (error) {\n        unset(validFieldsRef.current, name);\n        shouldReRender =\n          shouldReRender ||\n          !previousError ||\n          !deepEqual(previousError, error, true);\n        set(formStateRef.current.errors, name, error);\n      } else {\n        if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n          set(validFieldsRef.current, name, true);\n          shouldReRender = shouldReRender || previousError;\n        }\n\n        unset(formStateRef.current.errors, name);\n      }\n\n      if (\n        (shouldReRender && !isNullOrUndefined(shouldRender)) ||\n        !isEmptyObject(state)\n      ) {\n        updateFormState({\n          ...state,\n          errors: formStateRef.current.errors,\n          ...(resolverRef.current ? { isValid: !!isValid } : {}),\n        });\n      }\n    },\n    [],\n  );\n\n  const setFieldValue = React.useCallback(\n    (\n      name: string,\n      rawValue:\n        | FieldValue<TFieldValues>\n        | UnpackNestedValue<DeepPartial<TFieldValues>>\n        | string[]\n        | undefined\n        | null\n        | boolean,\n    ) => {\n      const { ref, options } = fieldsRef.current[name] as Field;\n      const value =\n        isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\n          ? ''\n          : rawValue;\n\n      if (isRadioInput(ref) && options) {\n        options.forEach(\n          ({ ref: radioRef }: { ref: HTMLInputElement }) =>\n            (radioRef.checked = radioRef.value === value),\n        );\n      } else if (isFileInput(ref) && !isString(value)) {\n        ref.files = value as FileList;\n      } else if (isMultipleSelect(ref)) {\n        [...ref.options].forEach(\n          (selectRef) =>\n            (selectRef.selected = (value as string[]).includes(\n              selectRef.value,\n            )),\n        );\n      } else if (isCheckBoxInput(ref) && options) {\n        options.length > 1\n          ? options.forEach(\n              ({ ref: checkboxRef }) =>\n                (checkboxRef.checked = Array.isArray(value)\n                  ? !!(value as []).find(\n                      (data: string) => data === checkboxRef.value,\n                    )\n                  : value === checkboxRef.value),\n            )\n          : (options[0].ref.checked = !!value);\n      } else {\n        ref.value = value;\n      }\n    },\n    [],\n  );\n\n  const isFormDirty = () =>\n    !deepEqual(\n      getValues(),\n      isEmptyObject(defaultValuesRef.current)\n        ? defaultValuesAtRenderRef.current\n        : defaultValuesRef.current,\n    ) || !isEmptyObject(formStateRef.current.dirtyFields);\n\n  const updateAndGetDirtyState = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      shouldRender = true,\n    ): {\n      dirtyFields?: FieldNamesMarkedBoolean<TFieldValues>;\n      isDirty?: boolean;\n      touched?: FieldNamesMarkedBoolean<TFieldValues>;\n    } => {\n      if (\n        readFormStateRef.current.isDirty ||\n        readFormStateRef.current.dirtyFields\n      ) {\n        const isFieldDirty = !deepEqual(\n          get(defaultValuesAtRenderRef.current, name),\n          getFieldValue(fieldsRef, name, shallowFieldsStateRef),\n        );\n        const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n        const previousIsDirty = formStateRef.current.isDirty;\n\n        isFieldDirty\n          ? set(formStateRef.current.dirtyFields, name, true)\n          : unset(formStateRef.current.dirtyFields, name);\n\n        const state = {\n          isDirty: isFormDirty(),\n          dirtyFields: formStateRef.current.dirtyFields,\n        };\n\n        const isChanged =\n          (readFormStateRef.current.isDirty &&\n            previousIsDirty !== state.isDirty) ||\n          (readFormStateRef.current.dirtyFields &&\n            isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\n\n        if (isChanged && shouldRender) {\n          formStateRef.current = {\n            ...formStateRef.current,\n            ...state,\n          };\n          updateFormState({\n            ...state,\n          });\n        }\n\n        return isChanged ? state : {};\n      }\n\n      return {};\n    },\n    [],\n  );\n\n  const executeValidation = React.useCallback(\n    async (\n      name: InternalFieldName<TFieldValues>,\n      skipReRender?: boolean | null,\n    ): Promise<boolean> => {\n      if (fieldsRef.current[name]) {\n        const error = (\n          await validateField<TFieldValues>(\n            fieldsRef,\n            isValidateAllFieldCriteria,\n            fieldsRef.current[name] as Field,\n            shallowFieldsStateRef,\n          )\n        )[name];\n\n        shouldRenderBaseOnError(name, error, skipReRender);\n\n        return isUndefined(error);\n      }\n\n      return false;\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const executeSchemaOrResolverValidation = React.useCallback(\n    async (\n      names:\n        | InternalFieldName<TFieldValues>\n        | InternalFieldName<TFieldValues>[],\n    ) => {\n      const { errors } = await resolverRef.current!(\n        getValues(),\n        contextRef.current,\n        isValidateAllFieldCriteria,\n      );\n      const previousFormIsValid = formStateRef.current.isValid;\n\n      if (Array.isArray(names)) {\n        const isInputsValid = names\n          .map((name) => {\n            const error = get(errors, name);\n\n            error\n              ? set(formStateRef.current.errors, name, error)\n              : unset(formStateRef.current.errors, name);\n\n            return !error;\n          })\n          .every(Boolean);\n\n        updateFormState({\n          isValid: isEmptyObject(errors),\n          errors: formStateRef.current.errors,\n        });\n\n        return isInputsValid;\n      } else {\n        const error = get(errors, names);\n\n        shouldRenderBaseOnError(\n          names,\n          error,\n          previousFormIsValid !== isEmptyObject(errors),\n          {},\n          isEmptyObject(errors),\n        );\n\n        return !error;\n      }\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const trigger = React.useCallback(\n    async (\n      name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n    ): Promise<boolean> => {\n      const fields = name || Object.keys(fieldsRef.current);\n\n      if (resolverRef.current) {\n        return executeSchemaOrResolverValidation(fields);\n      }\n\n      if (Array.isArray(fields)) {\n        !name && (formStateRef.current.errors = {});\n        const result = await Promise.all(\n          fields.map(async (data) => await executeValidation(data, null)),\n        );\n        updateFormState();\n        return result.every(Boolean);\n      }\n\n      return await executeValidation(fields, readFormStateRef.current.isValid);\n    },\n    [executeSchemaOrResolverValidation, executeValidation],\n  );\n\n  const setInternalValues = React.useCallback(\n    <T extends string, U extends object | unknown[]>(\n      name: T,\n      value: U,\n      { shouldDirty, shouldValidate }: SetValueConfig,\n    ) => {\n      const data = {};\n      set(data, name, value);\n\n      for (const fieldName of getPath(name, value)) {\n        if (fieldsRef.current[fieldName]) {\n          setFieldValue(fieldName, get(data, fieldName));\n          shouldDirty && updateAndGetDirtyState(fieldName);\n          shouldValidate && trigger(fieldName as FieldName<TFieldValues>);\n        }\n      }\n    },\n    [trigger, setFieldValue, updateAndGetDirtyState],\n  );\n\n  const setInternalValue = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      value: FieldValue<TFieldValues> | null | undefined | boolean,\n      config: SetValueConfig = {},\n    ) => {\n      if (fieldsRef.current[name]) {\n        setFieldValue(name, value);\n        config.shouldDirty && updateAndGetDirtyState(name);\n      } else if (!isPrimitive(value)) {\n        setInternalValues(name, value, config);\n\n        if (fieldArrayNamesRef.current.has(name)) {\n          fieldArrayDefaultValuesRef.current[name] = value;\n          resetFieldArrayFunctionRef.current[name]({\n            [name]: value,\n          } as UnpackNestedValue<DeepPartial<TFieldValues>>);\n\n          if (\n            (readFormStateRef.current.isDirty ||\n              readFormStateRef.current.dirtyFields) &&\n            config.shouldDirty\n          ) {\n            set(\n              formStateRef.current.dirtyFields,\n              name,\n              setFieldArrayDirtyFields(\n                value,\n                get(defaultValuesRef.current, name, []),\n                get(formStateRef.current.dirtyFields, name, []),\n              ),\n            );\n\n            updateFormState({\n              isDirty: !deepEqual(\n                { ...getValues(), [name]: value },\n                defaultValuesRef.current,\n              ),\n              dirtyFields: formStateRef.current.dirtyFields,\n            });\n          }\n        }\n      }\n\n      !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n    },\n    [updateAndGetDirtyState, setFieldValue, setInternalValues],\n  );\n\n  const isFieldWatched = (name: string) =>\n    isWatchAllRef.current ||\n    watchFieldsRef.current.has(name) ||\n    watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = (name: string, found = true): boolean => {\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (const key in useWatchFieldsRef.current) {\n        if (\n          !name ||\n          !useWatchFieldsRef.current[key].size ||\n          useWatchFieldsRef.current[key].has(name) ||\n          useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))\n        ) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name: TFieldName,\n    value: TFieldValue extends NestedValue<infer U>\n      ? U\n      : UnpackNestedValue<DeepPartial<LiteralToPrimitive<TFieldValue>>>,\n    config?: SetValueConfig,\n  ): void {\n    setInternalValue(name, value as TFieldValues[string], config);\n    isFieldWatched(name) && updateFormState();\n    renderWatchedInputs(name);\n    (config || {}).shouldValidate && trigger(name as any);\n  }\n\n  handleChangeRef.current = handleChangeRef.current\n    ? handleChangeRef.current\n    : async ({ type, target }: Event): Promise<void | boolean> => {\n        let name = (target as Ref)!.name;\n        const field = fieldsRef.current[name];\n        let error;\n        let isValid;\n\n        if (field) {\n          const isBlurEvent = type === EVENTS.BLUR;\n          const shouldSkipValidation = skipValidation({\n            isBlurEvent,\n            isReValidateOnChange,\n            isReValidateOnBlur,\n            isTouched: !!get(formStateRef.current.touched, name),\n            isSubmitted: formStateRef.current.isSubmitted,\n            ...modeRef.current,\n          });\n          let state = updateAndGetDirtyState(name, false);\n          let shouldRender = !isEmptyObject(state) || isFieldWatched(name);\n\n          if (\n            isBlurEvent &&\n            !get(formStateRef.current.touched, name) &&\n            readFormStateRef.current.touched\n          ) {\n            set(formStateRef.current.touched, name, true);\n            state = {\n              ...state,\n              touched: formStateRef.current.touched,\n            };\n          }\n\n          if (shouldSkipValidation) {\n            renderWatchedInputs(name);\n            return (\n              (!isEmptyObject(state) ||\n                (shouldRender && isEmptyObject(state))) &&\n              updateFormState(state)\n            );\n          }\n\n          if (resolverRef.current) {\n            const { errors } = await resolverRef.current(\n              getValues(),\n              contextRef.current,\n              isValidateAllFieldCriteria,\n            );\n            const previousFormIsValid = formStateRef.current.isValid;\n            error = get(errors, name);\n\n            if (!error && resolverRef.current) {\n              const parentNodeName = name.substring(\n                0,\n                name.lastIndexOf('.') > name.lastIndexOf('[')\n                  ? name.lastIndexOf('.')\n                  : name.lastIndexOf('['),\n              );\n              const currentError = get(errors, parentNodeName, {});\n              currentError.type &&\n                currentError.message &&\n                (error = currentError);\n\n              if (\n                parentNodeName &&\n                (currentError ||\n                  get(formStateRef.current.errors, parentNodeName))\n              ) {\n                name = parentNodeName;\n              }\n            }\n\n            isValid = isEmptyObject(errors);\n\n            if (previousFormIsValid !== isValid) {\n              shouldRender = true;\n            }\n          } else {\n            error = (\n              await validateField<TFieldValues>(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                shallowFieldsStateRef,\n              )\n            )[name];\n          }\n\n          renderWatchedInputs(name);\n          shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n        }\n      };\n\n  function setFieldArrayDefaultValues<T extends FieldValues>(data: T): T {\n    if (!shouldUnregister) {\n      let copy = cloneObject(data, isWeb);\n\n      for (const value of fieldArrayNamesRef.current) {\n        if (isKey(value) && !copy[value]) {\n          copy = {\n            ...copy,\n            [value]: [],\n          };\n        }\n      }\n\n      return copy;\n    }\n    return data;\n  }\n\n  function getValues(): UnpackNestedValue<TFieldValues>;\n  function getValues<TFieldName extends string, TFieldValue extends unknown>(\n    name: TFieldName,\n  ): TFieldName extends keyof TFieldValues\n    ? UnpackNestedValue<TFieldValues>[TFieldName]\n    : TFieldValue;\n  function getValues<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function getValues(payload?: string | string[]): unknown {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (Array.isArray(payload)) {\n      const data = {};\n\n      for (const name of payload) {\n        set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      }\n\n      return data;\n    }\n\n    return setFieldArrayDefaultValues(\n      getFieldsValues(fieldsRef, shallowFieldsStateRef),\n    );\n  }\n\n  const validateResolver = React.useCallback(\n    async (values = {}) => {\n      const { errors } = await resolverRef.current!(\n        {\n          ...defaultValuesRef.current,\n          ...getValues(),\n          ...values,\n        },\n        contextRef.current,\n        isValidateAllFieldCriteria,\n      );\n      const isValid = isEmptyObject(errors);\n\n      formStateRef.current.isValid !== isValid &&\n        updateFormState({\n          isValid,\n        });\n    },\n    [isValidateAllFieldCriteria],\n  );\n\n  const removeFieldEventListener = React.useCallback(\n    (field: Field, forceDelete?: boolean) =>\n      findRemovedFieldAndRemoveListener(\n        fieldsRef,\n        handleChangeRef.current!,\n        field,\n        shallowFieldsStateRef,\n        shouldUnregister,\n        forceDelete,\n      ),\n    [shouldUnregister],\n  );\n\n  const updateWatchedValue = (name: string) => {\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else if (watchFieldsRef) {\n      let shouldRenderUseWatch = true;\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          updateFormState();\n          shouldRenderUseWatch = false;\n          break;\n        }\n      }\n\n      shouldRenderUseWatch && renderWatchedInputs(name);\n    }\n  };\n\n  const removeFieldEventListenerAndRef = React.useCallback(\n    (field?: Field, forceDelete?: boolean) => {\n      if (field) {\n        removeFieldEventListener(field, forceDelete);\n\n        if (shouldUnregister && !compact(field.options || []).length) {\n          unset(defaultValuesAtRenderRef.current, field.ref.name);\n          unset(validFieldsRef.current, field.ref.name);\n          unset(fieldsWithValidationRef.current, field.ref.name);\n          unset(formStateRef.current.errors, field.ref.name);\n          set(formStateRef.current.dirtyFields, field.ref.name, true);\n\n          updateFormState({\n            errors: formStateRef.current.errors,\n            isDirty: isFormDirty(),\n            dirtyFields: formStateRef.current.dirtyFields,\n          });\n\n          readFormStateRef.current.isValid &&\n            resolverRef.current &&\n            validateResolver();\n          updateWatchedValue(field.ref.name);\n        }\n      }\n    },\n    [validateResolver, removeFieldEventListener],\n  );\n\n  function clearErrors(\n    name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    name &&\n      (Array.isArray(name) ? name : [name]).forEach((inputName) =>\n        fieldsRef.current[inputName]\n          ? isKey(inputName)\n            ? delete formStateRef.current.errors[inputName]\n            : set(formStateRef.current.errors, inputName, undefined)\n          : unset(formStateRef.current.errors, inputName),\n      );\n\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {},\n    });\n  }\n\n  function setError(name: FieldName<TFieldValues>, error: ErrorOption): void {\n    const ref = (fieldsRef.current[name] || {})!.ref;\n\n    set(formStateRef.current.errors, name, {\n      ...error,\n      ref,\n    });\n\n    updateFormState({\n      isValid: false,\n      errors: formStateRef.current.errors,\n    });\n\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  const watchInternal = React.useCallback(\n    (\n      fieldNames?: string | string[],\n      defaultValue?: unknown,\n      watchId?: string,\n    ) => {\n      const watchFields = watchId\n        ? useWatchFieldsRef.current[watchId]\n        : watchFieldsRef.current;\n      const combinedDefaultValues = isUndefined(defaultValue)\n        ? defaultValuesRef.current\n        : defaultValue;\n      const fieldValues = getFieldsValues<TFieldValues>(\n        fieldsRef,\n        shallowFieldsStateRef,\n        false,\n        fieldNames,\n      );\n\n      if (isString(fieldNames)) {\n        return assignWatchFields<TFieldValues>(\n          fieldValues,\n          fieldNames,\n          watchFields,\n          isUndefined(defaultValue)\n            ? get(combinedDefaultValues, fieldNames)\n            : (defaultValue as UnpackNestedValue<DeepPartial<TFieldValues>>),\n          true,\n        );\n      }\n\n      if (Array.isArray(fieldNames)) {\n        return fieldNames.reduce(\n          (previous, name) => ({\n            ...previous,\n            [name]: assignWatchFields<TFieldValues>(\n              fieldValues,\n              name,\n              watchFields,\n              combinedDefaultValues as UnpackNestedValue<\n                DeepPartial<TFieldValues>\n              >,\n            ),\n          }),\n          {},\n        );\n      }\n\n      isWatchAllRef.current = isUndefined(watchId);\n\n      return transformToNestObject(\n        (!isEmptyObject(fieldValues) && fieldValues) ||\n          (combinedDefaultValues as FieldValues),\n      );\n    },\n    [],\n  );\n\n  function watch(): UnpackNestedValue<TFieldValues>;\n  function watch<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name: TFieldName,\n    defaultValue?: UnpackNestedValue<LiteralToPrimitive<TFieldValue>>,\n  ): UnpackNestedValue<LiteralToPrimitive<TFieldValue>>;\n  function watch<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n    defaultValues?: UnpackNestedValue<\n      DeepPartial<Pick<TFieldValues, TFieldName>>\n    >,\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function watch(\n    names: string[],\n    defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ): UnpackNestedValue<DeepPartial<TFieldValues>>;\n  function watch(\n    fieldNames?: string | string[],\n    defaultValue?: unknown,\n  ): unknown {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(\n    name: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    for (const fieldName of Array.isArray(name) ? name : [name]) {\n      removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\n    }\n  }\n\n  function registerFieldRef<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: TFieldElement & Ref,\n    validateOptions: ValidationRules | null = {},\n  ): ((name: InternalFieldName<TFieldValues>) => void) | void {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn(\n          ' Field is missing `name` attribute',\n          ref,\n          `https://react-hook-form.com/api#useForm`,\n        );\n      }\n\n      if (\n        fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\n        !RegExp(\n          `^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`\n            .replace(/\\[/g, '\\\\[')\n            .replace(/\\]/g, '\\\\]'),\n        ).test(ref.name)\n      ) {\n        return console.warn(\n          ' `name` prop should be in object shape: name=\"test[index].name\"',\n          ref,\n          'https://react-hook-form.com/api#useFieldArray',\n        );\n      }\n    }\n\n    const { name, type, value } = ref;\n    const fieldRefAndValidationOptions = {\n      ref,\n      ...validateOptions,\n    };\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const compareRef = (currentRef: Ref) =>\n      isWeb && (!isHTMLElement(ref) || currentRef === ref);\n    let field = fields[name] as Field;\n    let isEmptyDefaultValue = true;\n    let defaultValue;\n\n    if (\n      field &&\n      (isRadioOrCheckbox\n        ? Array.isArray(field.options) &&\n          compact(field.options).find((option) => {\n            return value === option.ref.value && compareRef(option.ref);\n          })\n        : compareRef(field.ref))\n    ) {\n      fields[name] = {\n        ...field,\n        ...validateOptions,\n      };\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox\n        ? {\n            options: [\n              ...compact((field && field.options) || []),\n              {\n                ref,\n              } as RadioOrCheckboxOption,\n            ],\n            ref: { type, name },\n            ...validateOptions,\n          }\n        : {\n            ...fieldRefAndValidationOptions,\n          };\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n\n    const isEmptyUnmountFields = isUndefined(\n      get(shallowFieldsStateRef.current, name),\n    );\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(\n        isEmptyUnmountFields\n          ? defaultValuesRef.current\n          : shallowFieldsStateRef.current,\n        name,\n      );\n      isEmptyDefaultValue = isUndefined(defaultValue);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    if (!isEmptyObject(validateOptions)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(\n          fieldsRef,\n          isValidateAllFieldCriteria,\n          field,\n          shallowFieldsStateRef,\n        ).then((error: FieldErrors) => {\n          const previousFormIsValid = formStateRef.current.isValid;\n\n          isEmptyObject(error)\n            ? set(validFieldsRef.current, name, true)\n            : unset(validFieldsRef.current, name);\n\n          if (previousFormIsValid !== isEmptyObject(error)) {\n            updateFormState();\n          }\n        });\n      }\n    }\n\n    if (\n      !defaultValuesAtRenderRef.current[name] &&\n      !(isFieldArray && isEmptyDefaultValue)\n    ) {\n      const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n      set(\n        defaultValuesAtRenderRef.current,\n        name,\n        isEmptyDefaultValue\n          ? isObject(fieldValue)\n            ? { ...fieldValue }\n            : fieldValue\n          : defaultValue,\n      );\n      !isFieldArray && unset(formStateRef.current.dirtyFields, name);\n    }\n\n    if (type) {\n      attachEventListeners(\n        isRadioOrCheckbox && field.options\n          ? field.options[field.options.length - 1]\n          : field,\n        isRadioOrCheckbox || isSelectInput(ref),\n        handleChangeRef.current,\n      );\n    }\n  }\n\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    rules?: ValidationRules,\n  ): (ref: (TFieldElement & Ref) | null) => void;\n  function register(\n    name: FieldName<TFieldValues>,\n    rules?: ValidationRules,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: (TFieldElement & Ref) | null,\n    rules?: ValidationRules,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    refOrValidationOptions?:\n      | FieldName<TFieldValues>\n      | ValidationRules\n      | (TFieldElement & Ref)\n      | null,\n    rules?: ValidationRules,\n  ): ((ref: (TFieldElement & Ref) | null) => void) | void {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldRef({ name: refOrValidationOptions }, rules);\n      } else if (\n        isObject(refOrValidationOptions) &&\n        'name' in refOrValidationOptions\n      ) {\n        registerFieldRef(refOrValidationOptions, rules);\n      } else {\n        return (ref: (TFieldElement & Ref) | null) =>\n          ref && registerFieldRef(ref, refOrValidationOptions);\n      }\n    }\n  }\n\n  const handleSubmit = React.useCallback(\n    <TSubmitFieldValues extends FieldValues = TFieldValues>(\n      onValid: SubmitHandler<TSubmitFieldValues>,\n      onInvalid?: SubmitErrorHandler<TFieldValues>,\n    ) => async (e?: React.BaseSyntheticEvent): Promise<void> => {\n      if (e && e.preventDefault) {\n        e.preventDefault();\n        e.persist();\n      }\n      let fieldErrors: FieldErrors<TFieldValues> = {};\n      let fieldValues = setFieldArrayDefaultValues(\n        getFieldsValues(fieldsRef, shallowFieldsStateRef, true),\n      );\n\n      readFormStateRef.current.isSubmitting &&\n        updateFormState({\n          isSubmitting: true,\n        });\n\n      try {\n        if (resolverRef.current) {\n          const { errors, values } = await resolverRef.current(\n            fieldValues,\n            contextRef.current,\n            isValidateAllFieldCriteria,\n          );\n          formStateRef.current.errors = fieldErrors = errors;\n          fieldValues = values;\n        } else {\n          for (const field of Object.values(fieldsRef.current)) {\n            if (field) {\n              const {\n                ref: { name },\n              } = field;\n\n              const fieldError = await validateField(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                shallowFieldsStateRef,\n              );\n\n              if (fieldError[name]) {\n                set(fieldErrors, name, fieldError[name]);\n                unset(validFieldsRef.current, name);\n              } else if (get(fieldsWithValidationRef.current, name)) {\n                unset(formStateRef.current.errors, name);\n                set(validFieldsRef.current, name, true);\n              }\n            }\n          }\n        }\n\n        if (\n          isEmptyObject(fieldErrors) &&\n          Object.keys(formStateRef.current.errors).every(\n            (name) => name in fieldsRef.current,\n          )\n        ) {\n          updateFormState({\n            errors: {},\n            isSubmitting: true,\n          });\n          await onValid(fieldValues, e);\n        } else {\n          formStateRef.current.errors = {\n            ...formStateRef.current.errors,\n            ...fieldErrors,\n          };\n          onInvalid && (await onInvalid(formStateRef.current.errors, e));\n          shouldFocusError &&\n            focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\n        }\n      } finally {\n        updateFormState({\n          isSubmitted: true,\n          isSubmitting: false,\n          isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n          errors: formStateRef.current.errors,\n          submitCount: formStateRef.current.submitCount + 1,\n        });\n      }\n    },\n    [shouldFocusError, isValidateAllFieldCriteria],\n  );\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields,\n  }: OmitResetState) => {\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    defaultValuesAtRenderRef.current = {};\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n\n    updateFormState({\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: isValid ? formStateRef.current.isValid : false,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false,\n    });\n  };\n\n  const reset = (\n    values?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n    omitResetState: OmitResetState = {},\n  ): void => {\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const { ref, options } = field;\n          const inputRef =\n            isRadioOrCheckboxFunction(ref) && Array.isArray(options)\n              ? options[0].ref\n              : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form')!.reset();\n              break;\n            } catch {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n    defaultValuesRef.current = cloneObject(\n      values || defaultValuesRef.current,\n      isWeb,\n    );\n    values && renderWatchedInputs('');\n\n    Object.values(resetFieldArrayFunctionRef.current).forEach(\n      (resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray(),\n    );\n\n    shallowFieldsStateRef.current = shouldUnregister\n      ? {}\n      : cloneObject(values, isWeb) || {};\n\n    resetRefs(omitResetState);\n  };\n\n  React.useEffect(() => {\n    isUnMount.current = false;\n    resolver && readFormStateRef.current.isValid && validateResolver();\n\n    observerRef.current =\n      observerRef.current || !isWeb\n        ? observerRef.current\n        : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n\n    return () => {\n      isUnMount.current = true;\n      observerRef.current && observerRef.current.disconnect();\n      shallowFieldsStateRef.current = {};\n\n      if (process.env.NODE_ENV !== 'production') {\n        return;\n      }\n\n      Object.values(fieldsRef.current).forEach((field) =>\n        removeFieldEventListenerAndRef(field, true),\n      );\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid =\n      deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\n      isEmptyObject(formStateRef.current.errors);\n  }\n\n  const commonProps = {\n    trigger,\n    setValue: React.useCallback(setValue, [setInternalValue, trigger]),\n    getValues: React.useCallback(getValues, []),\n    register: React.useCallback(register, [defaultValuesRef.current]),\n    unregister: React.useCallback(unregister, []),\n  };\n\n  const control = {\n    updateWatchedValue,\n    shouldUnregister,\n    removeFieldEventListener,\n    watchInternal,\n    mode: modeRef.current,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange,\n    },\n    fieldsRef,\n    resetFieldArrayFunctionRef,\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    fieldArrayDefaultValuesRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    readFormStateRef,\n    formStateRef,\n    defaultValuesRef,\n    shallowFieldsStateRef,\n    updateFormState,\n    validateResolver: resolver ? validateResolver : undefined,\n    ...commonProps,\n  };\n\n  return {\n    watch,\n    control,\n    formState: isProxyEnabled\n      ? new Proxy(formState, {\n          get: (obj, prop: keyof FormStateProxy) => {\n            if (process.env.NODE_ENV !== 'production') {\n              if (prop === 'isValid' && isOnSubmit) {\n                console.warn(\n                  ' `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState',\n                );\n              }\n            }\n\n            if (prop in obj) {\n              readFormStateRef.current[prop] = true;\n              return obj[prop];\n            }\n\n            return undefined;\n          },\n        })\n      : formState,\n    handleSubmit,\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    setError: React.useCallback(setError, []),\n    errors: formState.errors,\n    ...commonProps,\n  };\n}\n","import * as React from 'react';\nimport { UseFormMethods, FieldValues, FormProviderProps } from './types';\n\nconst FormContext = React.createContext<UseFormMethods | null>(null);\n\nFormContext.displayName = 'RHFContext';\n\nexport const useFormContext = <\n  TFieldValues extends FieldValues\n>(): UseFormMethods<TFieldValues> =>\n  React.useContext(FormContext) as UseFormMethods<TFieldValues>;\n\nexport const FormProvider = <TFieldValues extends FieldValues>({\n  children,\n  ...props\n}: FormProviderProps<TFieldValues>) => (\n  <FormContext.Provider value={{ ...props } as UseFormMethods}>\n    {children}\n  </FormContext.Provider>\n);\n","import { UNDEFINED } from '../constants';\n\nexport default () => {\n  const d =\n    typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n","import isUndefined from './isUndefined';\nimport compact from './compact';\n\nconst removeAt = <T>(data: T[], index: number): T[] => [\n  ...data.slice(0, index),\n  ...data.slice(index + 1),\n];\n\nfunction removeAtIndexes<T>(data: T[], index: number[]): T[] {\n  let k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return compact(data);\n}\n\nexport default <T>(data: T[], index?: number | number[]): T[] =>\n  isUndefined(index)\n    ? []\n    : Array.isArray(index)\n    ? removeAtIndexes(data, index)\n    : removeAt(data, index);\n","import isUndefined from './isUndefined';\n\nexport default <T>(\n  data: (T | undefined)[],\n  from: number,\n  to: number,\n): (T | undefined)[] => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n","export default <T>(data: T[], indexA: number, indexB: number): void => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n","export default function prepend<T>(data: T[]): (T | undefined)[];\nexport default function prepend<T>(data: T[], value: T | T[]): T[];\nexport default function prepend<T>(\n  data: T[],\n  value?: T | T[],\n): (T | undefined)[] {\n  return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\n}\n","export default function insert<T>(data: T[], index: number): (T | undefined)[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value: T | T[],\n): T[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value?: T | T[],\n): (T | undefined)[] {\n  return [\n    ...data.slice(0, index),\n    ...(Array.isArray(value) ? value : [value || undefined]),\n    ...data.slice(index),\n  ];\n}\n","export default <T>(value: T | T[]): undefined[] | undefined =>\n  Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n","import isObject from './isObject';\n\nfunction mapValueToBoolean<U>(value: U): boolean[] | Record<string, boolean>[] {\n  if (isObject(value)) {\n    const object: Record<string, boolean> = {};\n\n    for (const key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nexport default <T>(value: T) =>\n  ((Array.isArray(value) ? value : [value]) as T[])\n    .map(mapValueToBoolean)\n    .flat();\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport { isMatchFieldArrayName } from './logic/isNameInFieldArray';\nimport generateId from './logic/generateId';\nimport deepEqual from './utils/deepEqual';\nimport getFieldArrayParentName from './logic/getFieldArrayParentName';\nimport get from './utils/get';\nimport set from './utils/set';\nimport isUndefined from './utils/isUndefined';\nimport removeArrayAt from './utils/remove';\nimport unset from './utils/unset';\nimport moveArrayAt from './utils/move';\nimport swapArrayAt from './utils/swap';\nimport prependAt from './utils/prepend';\nimport insertAt from './utils/insert';\nimport fillEmptyArray from './utils/fillEmptyArray';\nimport fillBooleanArray from './utils/fillBooleanArray';\nimport compact from './utils/compact';\nimport {\n  Field,\n  FieldValues,\n  UseFieldArrayOptions,\n  Control,\n  ArrayField,\n  UnpackNestedValue,\n  DeepPartial,\n  UseFieldArrayMethods,\n} from './types';\n\nconst mapIds = <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id'\n>(\n  values: Partial<TFieldArrayValues>[] = [],\n  keyName: TKeyName,\n): Partial<ArrayField<TFieldArrayValues, TKeyName>>[] => {\n  if (process.env.NODE_ENV !== 'production') {\n    for (const value of values) {\n      if (keyName in value) {\n        console.warn(\n          ` useFieldArray fieldValues contain the keyName \\`${keyName}\\` which is reserved for use by useFieldArray. https://react-hook-form.com/api#useFieldArray`,\n        );\n\n        break;\n      }\n    }\n  }\n\n  return values.map((value: Partial<TFieldArrayValues>) => ({\n    [keyName]: generateId(),\n    ...value,\n  }));\n};\n\nexport const useFieldArray = <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id',\n  TControl extends Control = Control\n>({\n  control,\n  name,\n  keyName = 'id' as TKeyName,\n}: UseFieldArrayOptions<TKeyName, TControl>): UseFieldArrayMethods<\n  TFieldArrayValues,\n  TKeyName\n> => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        ' useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray',\n      );\n    }\n  }\n\n  const focusIndexRef = React.useRef(-1);\n  const {\n    updateWatchedValue,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    formStateRef,\n    shallowFieldsStateRef,\n    updateFormState,\n    readFormStateRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n    validateResolver,\n    getValues,\n    shouldUnregister,\n  } = control || methods.control;\n\n  const fieldArrayParentName = getFieldArrayParentName(name);\n  const memoizedDefaultValues = React.useRef<Partial<TFieldArrayValues>[]>([\n    ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\n      ? get(fieldArrayDefaultValuesRef.current, name, [])\n      : get(\n          shouldUnregister\n            ? defaultValuesRef.current\n            : shallowFieldsStateRef.current,\n          name,\n          [],\n        )),\n  ]);\n  const [fields, setFields] = React.useState<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(mapIds(memoizedDefaultValues.current, keyName));\n  const allFields = React.useRef<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(fields);\n\n  const getCurrentFieldsValues = () =>\n    get(getValues(), name, allFields.current).map(\n      (item: Partial<TFieldArrayValues>, index: number) => ({\n        ...allFields.current[index],\n        ...item,\n      }),\n    );\n\n  allFields.current = fields;\n  fieldArrayNamesRef.current.add(name);\n\n  if (!get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\n    set(\n      fieldArrayDefaultValuesRef.current,\n      fieldArrayParentName,\n      get(defaultValuesRef.current, fieldArrayParentName),\n    );\n  }\n\n  const setFieldAndValidState = (\n    fieldsValues: Partial<ArrayField<TFieldArrayValues, TKeyName>>[],\n  ) => {\n    setFields(fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      const values = getValues();\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  const getIsDirtyState = (\n    flagOrFields?: (Partial<TFieldArrayValues> | undefined)[],\n  ): boolean =>\n    (readFormStateRef.current.isDirty ||\n      readFormStateRef.current.dirtyFields) &&\n    (isUndefined(flagOrFields) ||\n      !deepEqual(\n        flagOrFields.map(({ [keyName]: omitted, ...rest } = {}) => rest),\n        get(defaultValuesRef.current, name),\n      ));\n\n  const resetFields = () => {\n    for (const key in fieldsRef.current) {\n      isMatchFieldArrayName(key, name) &&\n        removeFieldEventListener(fieldsRef.current[key] as Field, true);\n    }\n  };\n\n  const cleanup = <T>(ref: T) =>\n    !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const updateDirtyFieldsWithDefaultValues = <\n    T extends { [k: string]: unknown }[]\n  >(\n    updatedFieldArrayValues?: T,\n  ) => {\n    const defaultFieldArrayValues = get(defaultValuesRef.current, name, []);\n    const updateDirtyFieldsBaseOnDefaultValues = <U extends T>(\n      base: U,\n      target: U,\n    ) => {\n      for (const key in base) {\n        for (const innerKey in base[key]) {\n          if (\n            innerKey !== keyName &&\n            (!target[key] ||\n              !base[key] ||\n              base[key][innerKey] !== target[key][innerKey])\n          ) {\n            set(formStateRef.current.dirtyFields, `${name}[${key}]`, {\n              ...get(formStateRef.current.dirtyFields, `${name}[${key}]`, {}),\n              [innerKey]: true,\n            });\n          }\n        }\n      }\n    };\n\n    if (updatedFieldArrayValues) {\n      updateDirtyFieldsBaseOnDefaultValues(\n        defaultFieldArrayValues,\n        updatedFieldArrayValues,\n      );\n      updateDirtyFieldsBaseOnDefaultValues(\n        updatedFieldArrayValues,\n        defaultFieldArrayValues,\n      );\n    }\n  };\n\n  const batchStateUpdate = <\n    T extends Function,\n    K extends { [k: string]: unknown }[]\n  >(\n    method: T,\n    args: {\n      argA?: unknown;\n      argB?: unknown;\n      argC?: unknown;\n      argD?: unknown;\n    },\n    updatedFieldValues?: K,\n    isDirty = true,\n    shouldSet = true,\n    shouldUpdateValid = false,\n  ) => {\n    if (get(shallowFieldsStateRef.current, name)) {\n      const output = method(\n        get(shallowFieldsStateRef.current, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      const output = method(\n        get(fieldArrayDefaultValuesRef.current, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\n      cleanup(fieldArrayDefaultValuesRef.current);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(\n        get(formStateRef.current.errors, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (\n      readFormStateRef.current.touched &&\n      get(formStateRef.current.touched, name)\n    ) {\n      const output = method(\n        get(formStateRef.current.touched, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.touched, name, output);\n      cleanup(formStateRef.current.touched);\n    }\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      const output = method(\n        get(formStateRef.current.dirtyFields, name, []),\n        args.argC,\n        args.argD,\n      );\n      shouldSet && set(formStateRef.current.dirtyFields, name, output);\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (\n      shouldUpdateValid &&\n      readFormStateRef.current.isValid &&\n      !validateResolver\n    ) {\n      set(\n        validFieldsRef.current,\n        name,\n        method(get(validFieldsRef.current, name, []), args.argA),\n      );\n      cleanup(validFieldsRef.current);\n\n      set(\n        fieldsWithValidationRef.current,\n        name,\n        method(get(fieldsWithValidationRef.current, name, []), args.argA),\n      );\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    updateFormState({\n      errors: formStateRef.current.errors,\n      dirtyFields: formStateRef.current.dirtyFields,\n      isDirty,\n      touched: formStateRef.current.touched,\n    });\n  };\n\n  const append = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const updateFormValues = [\n      ...allFields.current,\n      ...mapIds(Array.isArray(value) ? value : [value], keyName),\n    ];\n    setFieldAndValidState(updateFormValues);\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      updateDirtyFieldsWithDefaultValues(updateFormValues);\n\n      updateFormState({\n        isDirty: true,\n        dirtyFields: formStateRef.current.dirtyFields,\n      });\n    }\n\n    !shouldUnregister &&\n      set(shallowFieldsStateRef.current, name, [\n        ...(shallowFieldsStateRef.current[name] || []),\n        value,\n      ]);\n    focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\n  };\n\n  const prepend = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n    const updatedFieldArrayValues = prependAt(\n      getCurrentFieldsValues(),\n      mapIds(Array.isArray(value) ? value : [value], keyName),\n    );\n\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(\n      prependAt,\n      {\n        argA: emptyArray,\n        argC: fillBooleanArray(value),\n      },\n      updatedFieldArrayValues,\n    );\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = (index?: number | number[]) => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldValues: { [k: string]: unknown }[] = removeArrayAt(\n      fieldValues,\n      index,\n    );\n    setFieldAndValidState(\n      updatedFieldValues as Partial<ArrayField<TFieldArrayValues, TKeyName>>[],\n    );\n    resetFields();\n    batchStateUpdate(\n      removeArrayAt,\n      {\n        argA: index,\n        argC: index,\n      },\n      updatedFieldValues,\n      getIsDirtyState(removeArrayAt(fieldValues, index)),\n      true,\n      true,\n    );\n  };\n\n  const insert = (\n    index: number,\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldArrayValues = insertAt(\n      fieldValues,\n      index,\n      mapIds(Array.isArray(value) ? value : [value], keyName),\n    );\n\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(\n      insertAt,\n      {\n        argA: index,\n        argB: emptyArray,\n        argC: index,\n        argD: fillBooleanArray(value),\n      },\n      updatedFieldArrayValues,\n      getIsDirtyState(insertAt(fieldValues, index)),\n    );\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA: number, indexB: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(\n      swapArrayAt,\n      {\n        argA: indexA,\n        argB: indexB,\n        argC: indexA,\n        argD: indexB,\n      },\n      undefined,\n      getIsDirtyState(fieldValues),\n      false,\n    );\n  };\n\n  const move = (from: number, to: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(\n      moveArrayAt,\n      {\n        argA: from,\n        argB: to,\n        argC: from,\n        argD: to,\n      },\n      undefined,\n      getIsDirtyState(fieldValues),\n      false,\n    );\n  };\n\n  const reset = <TFieldValues>(\n    data?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ) => {\n    resetFields();\n    !data && unset(fieldArrayDefaultValuesRef.current, name);\n    unset(shallowFieldsStateRef.current, name);\n    memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\n    setFields(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!name) {\n        console.warn(\n          ' useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray',\n        );\n      }\n    }\n\n    const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      defaultValues.pop();\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues);\n    }\n\n    updateWatchedValue(name);\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n        if (\n          key.startsWith(`${name}[${focusIndexRef.current}]`) &&\n          field!.ref.focus\n        ) {\n          field!.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n\n  React.useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = reset;\n    }\n\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend, [name]),\n    append: React.useCallback(append, [name]),\n    remove: React.useCallback(remove, [name]),\n    insert: React.useCallback(insert, [name]),\n    fields,\n  };\n};\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport isUndefined from './utils/isUndefined';\nimport isString from './utils/isString';\nimport generateId from './logic/generateId';\nimport get from './utils/get';\nimport isObject from './utils/isObject';\nimport {\n  DeepPartial,\n  UseWatchOptions,\n  FieldValues,\n  UnpackNestedValue,\n  Control,\n} from './types';\n\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  control?: Control;\n}): undefined | UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  defaultValue: UnpackNestedValue<TWatchFieldValue>;\n  control?: Control;\n}): UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  name: string[];\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValues>({\n  control,\n  name,\n  defaultValue,\n}: UseWatchOptions): TWatchFieldValues {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        ' useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch',\n      );\n    }\n  }\n\n  const {\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    watchInternal,\n    defaultValuesRef,\n  } = control || methods.control;\n  const [value, setValue] = React.useState<unknown>(\n    isUndefined(defaultValue)\n      ? isString(name)\n        ? get(defaultValuesRef.current, name)\n        : Array.isArray(name)\n        ? name.reduce(\n            (previous, inputName) => ({\n              ...previous,\n              [inputName]: get(defaultValuesRef.current, inputName),\n            }),\n            {},\n          )\n        : defaultValuesRef.current\n      : defaultValue,\n  );\n  const idRef = React.useRef<string>();\n  const defaultValueRef = React.useRef(defaultValue);\n\n  const updateWatchValue = React.useCallback(() => {\n    const value = watchInternal(name, defaultValueRef.current, idRef.current);\n    setValue(\n      isObject(value)\n        ? { ...value }\n        : Array.isArray(value)\n        ? [...value]\n        : value,\n    );\n  }, [setValue, watchInternal, defaultValueRef, name, idRef]);\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (name === '') {\n        console.warn(\n          ' useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch',\n        );\n      }\n    }\n\n    const id = (idRef.current = generateId());\n    const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    const watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(name, defaultValueRef.current, id);\n\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [\n    name,\n    updateWatchValue,\n    useWatchRenderFunctionsRef,\n    useWatchFieldsRef,\n    watchInternal,\n    defaultValueRef,\n  ]);\n\n  return (isUndefined(value) ? defaultValue : value) as TWatchFieldValues;\n}\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isPrimitive from '../utils/isPrimitive';\n\nexport default (event: any) =>\n  isPrimitive(event) ||\n  !isObject(event.target) ||\n  (isObject(event.target) && !event.type)\n    ? event\n    : isUndefined(event.target.value)\n    ? event.target.checked\n    : event.target.value;\n","import * as React from 'react';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport getInputValue from './logic/getInputValue';\nimport skipValidation from './logic/skipValidation';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport { useFormContext } from './useFormContext';\nimport { VALUE } from './constants';\nimport { Control } from './types';\nimport { ControllerProps } from './types';\n\nconst Controller = <\n  TAs extends\n    | React.ReactElement\n    | React.ComponentType<any>\n    | 'input'\n    | 'select'\n    | 'textarea',\n  TControl extends Control = Control\n>({\n  name,\n  rules,\n  as,\n  render,\n  defaultValue,\n  control,\n  onFocus,\n  ...rest\n}: ControllerProps<TAs, TControl>) => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        ' Controller is missing `control` prop. https://react-hook-form.com/api#Controller',\n      );\n    }\n  }\n\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    trigger,\n    mode,\n    reValidateMode: { isReValidateOnBlur, isReValidateOnChange },\n    formStateRef: {\n      current: { isSubmitted, touched },\n    },\n    updateFormState,\n    readFormStateRef,\n    fieldsRef,\n    fieldArrayNamesRef,\n    shallowFieldsStateRef,\n  } = control || methods.control;\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n  const getInitialValue = () =>\n    !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\n      ? get(shallowFieldsStateRef.current, name)\n      : isUndefined(defaultValue)\n      ? get(defaultValuesRef.current, name)\n      : defaultValue;\n  const [value, setInputStateValue] = React.useState(getInitialValue());\n  const valueRef = React.useRef(value);\n  const ref = React.useRef({\n    focus: () => null,\n  });\n  const onFocusRef = React.useRef(onFocus || (() => ref.current.focus()));\n\n  const shouldValidate = (isBlurEvent?: boolean) =>\n    !skipValidation({\n      isBlurEvent,\n      isReValidateOnBlur,\n      isReValidateOnChange,\n      isSubmitted,\n      isTouched: !!get(touched, name),\n      ...mode,\n    });\n\n  const commonTask = ([event]: any[]) => {\n    const data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  const registerField = React.useCallback(() => {\n    if (process.env.NODE_ENV !== 'production' && !name) {\n      return console.warn(\n        ' Field is missing `name` prop. https://react-hook-form.com/api#Controller',\n      );\n    }\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = {\n        ref: fieldsRef.current[name]!.ref,\n        ...rules,\n      };\n    } else {\n      register(\n        Object.defineProperty(\n          {\n            name,\n            focus: onFocusRef.current,\n          },\n          VALUE,\n          {\n            set(data) {\n              setInputStateValue(data);\n              valueRef.current = data;\n            },\n            get() {\n              return valueRef.current;\n            },\n          },\n        ),\n        rules,\n      );\n      if (isNotFieldArray && !get(defaultValuesRef.current, name)) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  }, [rules, name, register]);\n\n  React.useEffect(() => () => unregister(name), [unregister, name]);\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (isUndefined(value)) {\n        console.warn(\n          ` ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`,\n        );\n      }\n\n      if ((!as && !render) || (as && render)) {\n        console.warn(\n          ` ${name} Controller should use either the 'as' or 'render' prop, not both. https://react-hook-form.com/api#Controller`,\n        );\n      }\n\n      if (!isNotFieldArray && isUndefined(defaultValue)) {\n        console.warn(\n          ' Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller',\n        );\n      }\n    }\n\n    registerField();\n  }, [registerField]);\n\n  React.useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n\n  const onBlur = () => {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched,\n      });\n    }\n\n    if (shouldValidate(true)) {\n      trigger(name);\n    }\n  };\n\n  const onChange = (...event: any[]) =>\n    setValue(name, commonTask(event), {\n      shouldValidate: shouldValidate(),\n      shouldDirty: true,\n    });\n\n  const commonProps = {\n    onChange,\n    onBlur,\n    name,\n    value,\n    ref,\n  };\n\n  const props = {\n    ...rest,\n    ...commonProps,\n  };\n\n  return as\n    ? React.isValidElement(as)\n      ? React.cloneElement(as, props)\n      : React.createElement(as as string, props as any)\n    : render\n    ? render(commonProps)\n    : null;\n};\n\nexport { Controller };\n"]},"metadata":{},"sourceType":"module"}